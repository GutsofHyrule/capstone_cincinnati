{"ast":null,"code":"export class ListNode {\n  constructor(value) {\n    this.next = null;\n    this.prev = null;\n    this.value = value;\n  }\n\n}\nexport class LinkedList {\n  constructor() {\n    this.clear();\n  }\n\n  head() {\n    return this._head;\n  }\n\n  tail() {\n    return this._tail;\n  }\n\n  clear() {\n    this._head = this._tail = null;\n  }\n\n  toArray() {\n    let out = [];\n    this.forEachNode(n => out.push(n));\n    return out;\n  }\n\n  nextNode(node) {\n    return node.next;\n  }\n\n  forEachNode(callback) {\n    let node = this._head;\n\n    while (node !== null) {\n      callback(node);\n      node = node.next;\n    }\n  }\n\n  insertBefore(node) {\n    let reference = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (reference === null) return this.append(node);\n    if (reference.prev) reference.prev.next = node;else this._head = node;\n    node.prev = reference.prev;\n    node.next = reference;\n    reference.prev = node;\n    return node;\n  }\n\n  append(node) {\n    let tail = this._tail;\n\n    if (tail) {\n      tail.next = node;\n      node.prev = tail;\n      node.next = null;\n    } else {\n      this._head = node;\n    }\n\n    return this._tail = node;\n  }\n\n  remove(node) {\n    if (node.prev) node.prev.next = node.next;else this._head = node.next;\n    if (node.next) node.next.prev = node.prev;else this._tail = node.prev;\n    return node;\n  }\n\n}\nexport class ListSlice {\n  constructor(head, tail) {\n    this._head = head;\n    this._tail = tail;\n  }\n\n  forEachNode(callback) {\n    let node = this._head;\n\n    while (node !== null) {\n      callback(node);\n      node = this.nextNode(node);\n    }\n  }\n\n  head() {\n    return this._head;\n  }\n\n  tail() {\n    return this._tail;\n  }\n\n  toArray() {\n    let out = [];\n    this.forEachNode(n => out.push(n));\n    return out;\n  }\n\n  nextNode(node) {\n    if (node === this._tail) return null;\n    return node.next;\n  }\n\n}\nexport const EMPTY_SLICE = new ListSlice(null, null);","map":{"version":3,"mappings":"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","names":["ListNode","constructor","value","next","prev","LinkedList","clear","head","_head","tail","_tail","toArray","out","forEachNode","n","push","nextNode","node","callback","insertBefore","reference","append","remove","ListSlice","EMPTY_SLICE"],"sourceRoot":"","sources":["../../../../packages/@glimmer/util/lib/list-utils.ts"],"sourcesContent":["import { Option } from './platform-utils';\n\nexport interface LinkedListNode {\n  next: Option<LinkedListNode>;\n  prev: Option<LinkedListNode>;\n}\n\nexport class ListNode<T> implements LinkedListNode {\n  public next: Option<ListNode<T>> = null;\n  public prev: Option<ListNode<T>> = null;\n  public value: T;\n\n  constructor(value: T) {\n    this.value = value;\n  }\n}\n\n// we are unable to express the constraint that T's .prev and .next are\n// themselves T. However, it will always be true, so trust us.\ntype trust = any;\n\nexport class LinkedList<T extends LinkedListNode> implements Slice<T> {\n  private _head!: Option<T>;\n  private _tail!: Option<T>;\n\n  constructor() {\n    this.clear();\n  }\n\n  head(): Option<T> {\n    return this._head;\n  }\n\n  tail(): Option<T> {\n    return this._tail;\n  }\n\n  clear() {\n    this._head = this._tail = null;\n  }\n\n  toArray(): T[] {\n    let out: T[] = [];\n    this.forEachNode(n => out.push(n));\n    return out;\n  }\n\n  nextNode(node: T): T {\n    return node.next as trust;\n  }\n\n  forEachNode(callback: (node: T) => void) {\n    let node = this._head;\n\n    while (node !== null) {\n      callback(node as trust);\n      node = node.next as trust;\n    }\n  }\n\n  insertBefore(node: T, reference: Option<T> = null): T {\n    if (reference === null) return this.append(node);\n\n    if (reference.prev) reference.prev.next = node;\n    else this._head = node;\n\n    node.prev = reference.prev;\n    node.next = reference;\n    reference.prev = node;\n\n    return node;\n  }\n\n  append(node: T): T {\n    let tail = this._tail;\n\n    if (tail) {\n      tail.next = node;\n      node.prev = tail;\n      node.next = null;\n    } else {\n      this._head = node;\n    }\n\n    return (this._tail = node);\n  }\n\n  remove(node: T): T {\n    if (node.prev) node.prev.next = node.next;\n    else this._head = node.next as trust;\n\n    if (node.next) node.next.prev = node.prev;\n    else this._tail = node.prev as trust;\n\n    return node;\n  }\n}\n\nexport interface Slice<T extends LinkedListNode> {\n  head(): Option<T>;\n  tail(): Option<T>;\n  nextNode(node: T): Option<T>;\n  forEachNode(callback: (node: T) => void): void;\n  toArray(): T[];\n}\n\nexport interface CloneableListNode extends LinkedListNode {\n  clone(): this;\n}\n\nexport class ListSlice<T extends LinkedListNode> implements Slice<T> {\n  private _head: Option<T>;\n  private _tail: Option<T>;\n\n  constructor(head: Option<T>, tail: Option<T>) {\n    this._head = head;\n    this._tail = tail;\n  }\n\n  forEachNode(callback: (node: T) => void) {\n    let node = this._head;\n\n    while (node !== null) {\n      callback(node);\n      node = this.nextNode(node);\n    }\n  }\n\n  head(): Option<T> {\n    return this._head;\n  }\n\n  tail(): Option<T> {\n    return this._tail;\n  }\n\n  toArray(): T[] {\n    let out: T[] = [];\n    this.forEachNode(n => out.push(n));\n    return out;\n  }\n\n  nextNode(node: T): Option<T> {\n    if (node === this._tail) return null;\n    return node.next as T;\n  }\n}\n\nexport const EMPTY_SLICE = new ListSlice(null, null);\n"]},"metadata":{},"sourceType":"module"}