{"ast":null,"code":"import b, { SYNTHETIC } from '../builders';\nimport { appendChild, parseElementBlockParams } from '../utils';\nimport { HandlebarsNodeVisitors } from './handlebars-node-visitors';\nimport SyntaxError from '../errors/syntax-error';\nimport builders from '../builders';\nimport traverse from '../traversal/traverse';\nimport print from '../generation/print';\nimport Walker from '../traversal/walker';\nimport * as handlebars from 'handlebars';\nimport { assign } from '@glimmer/util';\nexport const voidMap = Object.create(null);\nlet voidTagNames = 'area base br col command embed hr img input keygen link meta param source track wbr';\nvoidTagNames.split(' ').forEach(tagName => {\n  voidMap[tagName] = true;\n});\nexport class TokenizerEventHandlers extends HandlebarsNodeVisitors {\n  constructor() {\n    super(...arguments);\n    this.tagOpenLine = 0;\n    this.tagOpenColumn = 0;\n  }\n\n  reset() {\n    this.currentNode = null;\n  } // Comment\n\n\n  beginComment() {\n    this.currentNode = b.comment('');\n    this.currentNode.loc = {\n      source: null,\n      start: b.pos(this.tagOpenLine, this.tagOpenColumn),\n      end: null\n    };\n  }\n\n  appendToCommentData(char) {\n    this.currentComment.value += char;\n  }\n\n  finishComment() {\n    this.currentComment.loc.end = b.pos(this.tokenizer.line, this.tokenizer.column);\n    appendChild(this.currentElement(), this.currentComment);\n  } // Data\n\n\n  beginData() {\n    this.currentNode = b.text();\n    this.currentNode.loc = {\n      source: null,\n      start: b.pos(this.tokenizer.line, this.tokenizer.column),\n      end: null\n    };\n  }\n\n  appendToData(char) {\n    this.currentData.chars += char;\n  }\n\n  finishData() {\n    this.currentData.loc.end = b.pos(this.tokenizer.line, this.tokenizer.column);\n    appendChild(this.currentElement(), this.currentData);\n  } // Tags - basic\n\n\n  tagOpen() {\n    this.tagOpenLine = this.tokenizer.line;\n    this.tagOpenColumn = this.tokenizer.column;\n  }\n\n  beginStartTag() {\n    this.currentNode = {\n      type: 'StartTag',\n      name: '',\n      attributes: [],\n      modifiers: [],\n      comments: [],\n      selfClosing: false,\n      loc: SYNTHETIC\n    };\n  }\n\n  beginEndTag() {\n    this.currentNode = {\n      type: 'EndTag',\n      name: '',\n      attributes: [],\n      modifiers: [],\n      comments: [],\n      selfClosing: false,\n      loc: SYNTHETIC\n    };\n  }\n\n  finishTag() {\n    let {\n      line,\n      column\n    } = this.tokenizer;\n    let tag = this.currentTag;\n    tag.loc = b.loc(this.tagOpenLine, this.tagOpenColumn, line, column);\n\n    if (tag.type === 'StartTag') {\n      this.finishStartTag();\n\n      if (voidMap[tag.name] || tag.selfClosing) {\n        this.finishEndTag(true);\n      }\n    } else if (tag.type === 'EndTag') {\n      this.finishEndTag(false);\n    }\n  }\n\n  finishStartTag() {\n    let {\n      name,\n      attributes,\n      modifiers,\n      comments,\n      selfClosing\n    } = this.currentStartTag;\n    let loc = b.loc(this.tagOpenLine, this.tagOpenColumn);\n    let element = b.element({\n      name,\n      selfClosing\n    }, attributes, modifiers, [], comments, [], loc);\n    this.elementStack.push(element);\n  }\n\n  finishEndTag(isVoid) {\n    let tag = this.currentTag;\n    let element = this.elementStack.pop();\n    let parent = this.currentElement();\n    validateEndTag(tag, element, isVoid);\n    element.loc.end.line = this.tokenizer.line;\n    element.loc.end.column = this.tokenizer.column;\n    parseElementBlockParams(element);\n    appendChild(parent, element);\n  }\n\n  markTagAsSelfClosing() {\n    this.currentTag.selfClosing = true;\n  } // Tags - name\n\n\n  appendToTagName(char) {\n    this.currentTag.name += char;\n  } // Tags - attributes\n\n\n  beginAttribute() {\n    let tag = this.currentTag;\n\n    if (tag.type === 'EndTag') {\n      throw new SyntaxError(`Invalid end tag: closing tag must not have attributes, ` + `in \\`${tag.name}\\` (on line ${this.tokenizer.line}).`, tag.loc);\n    }\n\n    this.currentAttribute = {\n      name: '',\n      parts: [],\n      isQuoted: false,\n      isDynamic: false,\n      start: b.pos(this.tokenizer.line, this.tokenizer.column),\n      valueStartLine: 0,\n      valueStartColumn: 0\n    };\n  }\n\n  appendToAttributeName(char) {\n    this.currentAttr.name += char;\n  }\n\n  beginAttributeValue(isQuoted) {\n    this.currentAttr.isQuoted = isQuoted;\n    this.currentAttr.valueStartLine = this.tokenizer.line;\n    this.currentAttr.valueStartColumn = this.tokenizer.column;\n  }\n\n  appendToAttributeValue(char) {\n    let parts = this.currentAttr.parts;\n    let lastPart = parts[parts.length - 1];\n\n    if (lastPart && lastPart.type === 'TextNode') {\n      lastPart.chars += char; // update end location for each added char\n\n      lastPart.loc.end.line = this.tokenizer.line;\n      lastPart.loc.end.column = this.tokenizer.column;\n    } else {\n      // initially assume the text node is a single char\n      let loc = b.loc(this.tokenizer.line, this.tokenizer.column, this.tokenizer.line, this.tokenizer.column); // correct for `\\n` as first char\n\n      if (char === '\\n') {\n        loc.start.line -= 1;\n        loc.start.column = lastPart ? lastPart.loc.end.column : this.currentAttr.valueStartColumn;\n      }\n\n      let text = b.text(char, loc);\n      parts.push(text);\n    }\n  }\n\n  finishAttributeValue() {\n    let {\n      name,\n      parts,\n      isQuoted,\n      isDynamic,\n      valueStartLine,\n      valueStartColumn\n    } = this.currentAttr;\n    let value = assembleAttributeValue(parts, isQuoted, isDynamic, this.tokenizer.line);\n    value.loc = b.loc(valueStartLine, valueStartColumn, this.tokenizer.line, this.tokenizer.column);\n    let loc = b.loc(this.currentAttr.start.line, this.currentAttr.start.column, this.tokenizer.line, this.tokenizer.column);\n    let attribute = b.attr(name, value, loc);\n    this.currentStartTag.attributes.push(attribute);\n  }\n\n  reportSyntaxError(message) {\n    throw new SyntaxError(`Syntax error at line ${this.tokenizer.line} col ${this.tokenizer.column}: ${message}`, b.loc(this.tokenizer.line, this.tokenizer.column));\n  }\n\n}\n\nfunction assembleAttributeValue(parts, isQuoted, isDynamic, line) {\n  if (isDynamic) {\n    if (isQuoted) {\n      return assembleConcatenatedValue(parts);\n    } else {\n      if (parts.length === 1 || parts.length === 2 && parts[1].type === 'TextNode' && parts[1].chars === '/') {\n        return parts[0];\n      } else {\n        throw new SyntaxError(`An unquoted attribute value must be a string or a mustache, ` + `preceeded by whitespace or a '=' character, and ` + `followed by whitespace, a '>' character, or '/>' (on line ${line})`, b.loc(line, 0));\n      }\n    }\n  } else {\n    return parts.length > 0 ? parts[0] : b.text('');\n  }\n}\n\nfunction assembleConcatenatedValue(parts) {\n  for (let i = 0; i < parts.length; i++) {\n    let part = parts[i];\n\n    if (part.type !== 'MustacheStatement' && part.type !== 'TextNode') {\n      throw new SyntaxError('Unsupported node in quoted attribute value: ' + part['type'], part.loc);\n    }\n  }\n\n  return b.concat(parts);\n}\n\nfunction validateEndTag(tag, element, selfClosing) {\n  let error;\n\n  if (voidMap[tag.name] && !selfClosing) {\n    // EngTag is also called by StartTag for void and self-closing tags (i.e.\n    // <input> or <br />, so we need to check for that here. Otherwise, we would\n    // throw an error for those cases.\n    error = 'Invalid end tag ' + formatEndTagInfo(tag) + ' (void elements cannot have end tags).';\n  } else if (element.tag === undefined) {\n    error = 'Closing tag ' + formatEndTagInfo(tag) + ' without an open tag.';\n  } else if (element.tag !== tag.name) {\n    error = 'Closing tag ' + formatEndTagInfo(tag) + ' did not match last open tag `' + element.tag + '` (on line ' + element.loc.start.line + ').';\n  }\n\n  if (error) {\n    throw new SyntaxError(error, element.loc);\n  }\n}\n\nfunction formatEndTagInfo(tag) {\n  return '`' + tag.name + '` (on line ' + tag.loc.end.line + ')';\n}\n\nconst syntax = {\n  parse: preprocess,\n  builders,\n  print,\n  traverse,\n  Walker\n};\nexport function preprocess(html, options) {\n  const parseOptions = options ? options.parseOptions : {};\n  let ast = typeof html === 'object' ? html : handlebars.parse(html, parseOptions);\n  let program = new TokenizerEventHandlers(html).acceptNode(ast);\n\n  if (options && options.plugins && options.plugins.ast) {\n    for (let i = 0, l = options.plugins.ast.length; i < l; i++) {\n      let transform = options.plugins.ast[i];\n      let env = assign({}, options, {\n        syntax\n      }, {\n        plugins: undefined\n      });\n      let pluginResult = transform(env);\n      traverse(program, pluginResult.visitor);\n    }\n  }\n\n  return program;\n}","map":{"version":3,"mappings":"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","names":["b","SYNTHETIC","appendChild","parseElementBlockParams","HandlebarsNodeVisitors","SyntaxError","builders","traverse","print","Walker","handlebars","assign","voidMap","Object","create","voidTagNames","split","forEach","tagName","TokenizerEventHandlers","constructor","tagOpenLine","tagOpenColumn","reset","currentNode","beginComment","comment","loc","source","start","pos","end","appendToCommentData","char","currentComment","value","finishComment","tokenizer","line","column","currentElement","beginData","text","appendToData","currentData","chars","finishData","tagOpen","beginStartTag","type","name","attributes","modifiers","comments","selfClosing","beginEndTag","finishTag","tag","currentTag","finishStartTag","finishEndTag","currentStartTag","element","elementStack","push","isVoid","pop","parent","validateEndTag","markTagAsSelfClosing","appendToTagName","beginAttribute","currentAttribute","parts","isQuoted","isDynamic","valueStartLine","valueStartColumn","appendToAttributeName","currentAttr","beginAttributeValue","appendToAttributeValue","lastPart","length","finishAttributeValue","assembleAttributeValue","attribute","attr","reportSyntaxError","message","assembleConcatenatedValue","i","part","concat","error","formatEndTagInfo","undefined","syntax","parse","preprocess","html","options","parseOptions","ast","program","acceptNode","plugins","l","transform","env","pluginResult","visitor"],"sourceRoot":"","sources":["../../../../../packages/@glimmer/syntax/lib/parser/tokenizer-event-handlers.ts"],"sourcesContent":["import b, { SYNTHETIC } from '../builders';\nimport { appendChild, parseElementBlockParams } from '../utils';\nimport { HandlebarsNodeVisitors } from './handlebars-node-visitors';\nimport * as AST from '../types/nodes';\nimport SyntaxError from '../errors/syntax-error';\nimport { Tag } from '../parser';\nimport builders from '../builders';\nimport traverse from '../traversal/traverse';\nimport { NodeVisitor } from '../types/visitor';\nimport print from '../generation/print';\nimport Walker from '../traversal/walker';\nimport * as handlebars from 'handlebars';\nimport { assign } from '@glimmer/util';\n\nexport const voidMap: {\n  [tagName: string]: boolean;\n} = Object.create(null);\n\nlet voidTagNames =\n  'area base br col command embed hr img input keygen link meta param source track wbr';\nvoidTagNames.split(' ').forEach(tagName => {\n  voidMap[tagName] = true;\n});\n\nexport class TokenizerEventHandlers extends HandlebarsNodeVisitors {\n  private tagOpenLine = 0;\n  private tagOpenColumn = 0;\n\n  reset() {\n    this.currentNode = null;\n  }\n\n  // Comment\n\n  beginComment() {\n    this.currentNode = b.comment('');\n    this.currentNode.loc = {\n      source: null,\n      start: b.pos(this.tagOpenLine, this.tagOpenColumn),\n      end: (null as any) as AST.Position,\n    };\n  }\n\n  appendToCommentData(char: string) {\n    this.currentComment.value += char;\n  }\n\n  finishComment() {\n    this.currentComment.loc.end = b.pos(this.tokenizer.line, this.tokenizer.column);\n\n    appendChild(this.currentElement(), this.currentComment);\n  }\n\n  // Data\n\n  beginData() {\n    this.currentNode = b.text();\n    this.currentNode.loc = {\n      source: null,\n      start: b.pos(this.tokenizer.line, this.tokenizer.column),\n      end: (null as any) as AST.Position,\n    };\n  }\n\n  appendToData(char: string) {\n    this.currentData.chars += char;\n  }\n\n  finishData() {\n    this.currentData.loc.end = b.pos(this.tokenizer.line, this.tokenizer.column);\n\n    appendChild(this.currentElement(), this.currentData);\n  }\n\n  // Tags - basic\n\n  tagOpen() {\n    this.tagOpenLine = this.tokenizer.line;\n    this.tagOpenColumn = this.tokenizer.column;\n  }\n\n  beginStartTag() {\n    this.currentNode = {\n      type: 'StartTag',\n      name: '',\n      attributes: [],\n      modifiers: [],\n      comments: [],\n      selfClosing: false,\n      loc: SYNTHETIC,\n    };\n  }\n\n  beginEndTag() {\n    this.currentNode = {\n      type: 'EndTag',\n      name: '',\n      attributes: [],\n      modifiers: [],\n      comments: [],\n      selfClosing: false,\n      loc: SYNTHETIC,\n    };\n  }\n\n  finishTag() {\n    let { line, column } = this.tokenizer;\n\n    let tag = this.currentTag;\n    tag.loc = b.loc(this.tagOpenLine, this.tagOpenColumn, line, column);\n\n    if (tag.type === 'StartTag') {\n      this.finishStartTag();\n\n      if (voidMap[tag.name] || tag.selfClosing) {\n        this.finishEndTag(true);\n      }\n    } else if (tag.type === 'EndTag') {\n      this.finishEndTag(false);\n    }\n  }\n\n  finishStartTag() {\n    let { name, attributes, modifiers, comments, selfClosing } = this.currentStartTag;\n    let loc = b.loc(this.tagOpenLine, this.tagOpenColumn);\n    let element = b.element({ name, selfClosing }, attributes, modifiers, [], comments, [], loc);\n    this.elementStack.push(element);\n  }\n\n  finishEndTag(isVoid: boolean) {\n    let tag = this.currentTag;\n\n    let element = this.elementStack.pop() as AST.ElementNode;\n    let parent = this.currentElement();\n\n    validateEndTag(tag, element, isVoid);\n\n    element.loc.end.line = this.tokenizer.line;\n    element.loc.end.column = this.tokenizer.column;\n\n    parseElementBlockParams(element);\n    appendChild(parent, element);\n  }\n\n  markTagAsSelfClosing() {\n    this.currentTag.selfClosing = true;\n  }\n\n  // Tags - name\n\n  appendToTagName(char: string) {\n    this.currentTag.name += char;\n  }\n\n  // Tags - attributes\n\n  beginAttribute() {\n    let tag = this.currentTag;\n    if (tag.type === 'EndTag') {\n      throw new SyntaxError(\n        `Invalid end tag: closing tag must not have attributes, ` +\n          `in \\`${tag.name}\\` (on line ${this.tokenizer.line}).`,\n        tag.loc\n      );\n    }\n\n    this.currentAttribute = {\n      name: '',\n      parts: [],\n      isQuoted: false,\n      isDynamic: false,\n      start: b.pos(this.tokenizer.line, this.tokenizer.column),\n      valueStartLine: 0,\n      valueStartColumn: 0,\n    };\n  }\n\n  appendToAttributeName(char: string) {\n    this.currentAttr.name += char;\n  }\n\n  beginAttributeValue(isQuoted: boolean) {\n    this.currentAttr.isQuoted = isQuoted;\n    this.currentAttr.valueStartLine = this.tokenizer.line;\n    this.currentAttr.valueStartColumn = this.tokenizer.column;\n  }\n\n  appendToAttributeValue(char: string) {\n    let parts = this.currentAttr.parts;\n    let lastPart = parts[parts.length - 1];\n\n    if (lastPart && lastPart.type === 'TextNode') {\n      lastPart.chars += char;\n\n      // update end location for each added char\n      lastPart.loc.end.line = this.tokenizer.line;\n      lastPart.loc.end.column = this.tokenizer.column;\n    } else {\n      // initially assume the text node is a single char\n      let loc = b.loc(\n        this.tokenizer.line,\n        this.tokenizer.column,\n        this.tokenizer.line,\n        this.tokenizer.column\n      );\n\n      // correct for `\\n` as first char\n      if (char === '\\n') {\n        loc.start.line -= 1;\n        loc.start.column = lastPart ? lastPart.loc.end.column : this.currentAttr.valueStartColumn;\n      }\n\n      let text = b.text(char, loc);\n      parts.push(text);\n    }\n  }\n\n  finishAttributeValue() {\n    let { name, parts, isQuoted, isDynamic, valueStartLine, valueStartColumn } = this.currentAttr;\n    let value = assembleAttributeValue(parts, isQuoted, isDynamic, this.tokenizer.line);\n    value.loc = b.loc(valueStartLine, valueStartColumn, this.tokenizer.line, this.tokenizer.column);\n\n    let loc = b.loc(\n      this.currentAttr.start.line,\n      this.currentAttr.start.column,\n      this.tokenizer.line,\n      this.tokenizer.column\n    );\n\n    let attribute = b.attr(name, value, loc);\n\n    this.currentStartTag.attributes.push(attribute);\n  }\n\n  reportSyntaxError(message: string) {\n    throw new SyntaxError(\n      `Syntax error at line ${this.tokenizer.line} col ${this.tokenizer.column}: ${message}`,\n      b.loc(this.tokenizer.line, this.tokenizer.column)\n    );\n  }\n}\n\nfunction assembleAttributeValue(\n  parts: (AST.MustacheStatement | AST.TextNode)[],\n  isQuoted: boolean,\n  isDynamic: boolean,\n  line: number\n) {\n  if (isDynamic) {\n    if (isQuoted) {\n      return assembleConcatenatedValue(parts);\n    } else {\n      if (\n        parts.length === 1 ||\n        (parts.length === 2 &&\n          parts[1].type === 'TextNode' &&\n          (parts[1] as AST.TextNode).chars === '/')\n      ) {\n        return parts[0];\n      } else {\n        throw new SyntaxError(\n          `An unquoted attribute value must be a string or a mustache, ` +\n            `preceeded by whitespace or a '=' character, and ` +\n            `followed by whitespace, a '>' character, or '/>' (on line ${line})`,\n          b.loc(line, 0)\n        );\n      }\n    }\n  } else {\n    return parts.length > 0 ? parts[0] : b.text('');\n  }\n}\n\nfunction assembleConcatenatedValue(parts: (AST.MustacheStatement | AST.TextNode)[]) {\n  for (let i = 0; i < parts.length; i++) {\n    let part: AST.BaseNode = parts[i];\n\n    if (part.type !== 'MustacheStatement' && part.type !== 'TextNode') {\n      throw new SyntaxError(\n        'Unsupported node in quoted attribute value: ' + part['type'],\n        part.loc\n      );\n    }\n  }\n\n  return b.concat(parts);\n}\n\nfunction validateEndTag(\n  tag: Tag<'StartTag' | 'EndTag'>,\n  element: AST.ElementNode,\n  selfClosing: boolean\n) {\n  let error;\n\n  if (voidMap[tag.name] && !selfClosing) {\n    // EngTag is also called by StartTag for void and self-closing tags (i.e.\n    // <input> or <br />, so we need to check for that here. Otherwise, we would\n    // throw an error for those cases.\n    error = 'Invalid end tag ' + formatEndTagInfo(tag) + ' (void elements cannot have end tags).';\n  } else if (element.tag === undefined) {\n    error = 'Closing tag ' + formatEndTagInfo(tag) + ' without an open tag.';\n  } else if (element.tag !== tag.name) {\n    error =\n      'Closing tag ' +\n      formatEndTagInfo(tag) +\n      ' did not match last open tag `' +\n      element.tag +\n      '` (on line ' +\n      element.loc.start.line +\n      ').';\n  }\n\n  if (error) {\n    throw new SyntaxError(error, element.loc);\n  }\n}\n\nfunction formatEndTagInfo(tag: Tag<'StartTag' | 'EndTag'>) {\n  return '`' + tag.name + '` (on line ' + tag.loc.end.line + ')';\n}\n\n/**\n  ASTPlugins can make changes to the Glimmer template AST before\n  compilation begins.\n*/\nexport interface ASTPluginBuilder {\n  (env: ASTPluginEnvironment): ASTPlugin;\n}\n\nexport interface ASTPlugin {\n  name: string;\n  visitor: NodeVisitor;\n}\n\nexport interface ASTPluginEnvironment {\n  meta?: any;\n  syntax: Syntax;\n}\n\nexport interface PreprocessOptions {\n  plugins?: {\n    ast?: ASTPluginBuilder[];\n  };\n  parseOptions?: object;\n}\n\nexport interface Syntax {\n  parse: typeof preprocess;\n  builders: typeof builders;\n  print: typeof print;\n  traverse: typeof traverse;\n  Walker: typeof Walker;\n}\n\nconst syntax: Syntax = {\n  parse: preprocess,\n  builders,\n  print,\n  traverse,\n  Walker,\n};\n\nexport function preprocess(html: string, options?: PreprocessOptions): AST.Program {\n  const parseOptions = options ? options.parseOptions : {};\n  let ast = typeof html === 'object' ? html : handlebars.parse(html, parseOptions);\n  let program = new TokenizerEventHandlers(html).acceptNode(ast);\n\n  if (options && options.plugins && options.plugins.ast) {\n    for (let i = 0, l = options.plugins.ast.length; i < l; i++) {\n      let transform = options.plugins.ast[i];\n      let env = assign({}, options, { syntax }, { plugins: undefined });\n\n      let pluginResult = transform(env);\n\n      traverse(program, pluginResult.visitor);\n    }\n  }\n\n  return program;\n}\n"]},"metadata":{},"sourceType":"module"}