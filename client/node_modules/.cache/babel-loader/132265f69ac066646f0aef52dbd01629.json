{"ast":null,"code":"'use strict';\n\nexports.__esModule = true; // istanbul ignore next\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar _base = require('../base');\n\nvar _exception = require('../exception');\n\nvar _exception2 = _interopRequireDefault(_exception);\n\nvar _utils = require('../utils');\n\nvar _codeGen = require('./code-gen');\n\nvar _codeGen2 = _interopRequireDefault(_codeGen);\n\nfunction Literal(value) {\n  this.value = value;\n}\n\nfunction JavaScriptCompiler() {}\n\nJavaScriptCompiler.prototype = {\n  // PUBLIC API: You can override these methods in a subclass to provide\n  // alternative compiled forms for name lookup and buffering semantics\n  nameLookup: function nameLookup(parent, name\n  /*,  type */\n  ) {\n    return this.internalNameLookup(parent, name);\n  },\n  depthedLookup: function depthedLookup(name) {\n    return [this.aliasable('container.lookup'), '(depths, ', JSON.stringify(name), ')'];\n  },\n  compilerInfo: function compilerInfo() {\n    var revision = _base.COMPILER_REVISION,\n        versions = _base.REVISION_CHANGES[revision];\n    return [revision, versions];\n  },\n  appendToBuffer: function appendToBuffer(source, location, explicit) {\n    // Force a source as this simplifies the merge logic.\n    if (!_utils.isArray(source)) {\n      source = [source];\n    }\n\n    source = this.source.wrap(source, location);\n\n    if (this.environment.isSimple) {\n      return ['return ', source, ';'];\n    } else if (explicit) {\n      // This is a case where the buffer operation occurs as a child of another\n      // construct, generally braces. We have to explicitly output these buffer\n      // operations to ensure that the emitted code goes in the correct location.\n      return ['buffer += ', source, ';'];\n    } else {\n      source.appendToBuffer = true;\n      return source;\n    }\n  },\n  initializeBuffer: function initializeBuffer() {\n    return this.quotedString('');\n  },\n  // END PUBLIC API\n  internalNameLookup: function internalNameLookup(parent, name) {\n    this.lookupPropertyFunctionIsUsed = true;\n    return ['lookupProperty(', parent, ',', JSON.stringify(name), ')'];\n  },\n  lookupPropertyFunctionIsUsed: false,\n  compile: function compile(environment, options, context, asObject) {\n    this.environment = environment;\n    this.options = options;\n    this.stringParams = this.options.stringParams;\n    this.trackIds = this.options.trackIds;\n    this.precompile = !asObject;\n    this.name = this.environment.name;\n    this.isChild = !!context;\n    this.context = context || {\n      decorators: [],\n      programs: [],\n      environments: []\n    };\n    this.preamble();\n    this.stackSlot = 0;\n    this.stackVars = [];\n    this.aliases = {};\n    this.registers = {\n      list: []\n    };\n    this.hashes = [];\n    this.compileStack = [];\n    this.inlineStack = [];\n    this.blockParams = [];\n    this.compileChildren(environment, options);\n    this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;\n    this.useBlockParams = this.useBlockParams || environment.useBlockParams;\n    var opcodes = environment.opcodes,\n        opcode = undefined,\n        firstLoc = undefined,\n        i = undefined,\n        l = undefined;\n\n    for (i = 0, l = opcodes.length; i < l; i++) {\n      opcode = opcodes[i];\n      this.source.currentLocation = opcode.loc;\n      firstLoc = firstLoc || opcode.loc;\n      this[opcode.opcode].apply(this, opcode.args);\n    } // Flush any trailing content that might be pending.\n\n\n    this.source.currentLocation = firstLoc;\n    this.pushSource('');\n    /* istanbul ignore next */\n\n    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {\n      throw new _exception2['default']('Compile completed with content left on stack');\n    }\n\n    if (!this.decorators.isEmpty()) {\n      this.useDecorators = true;\n      this.decorators.prepend(['var decorators = container.decorators, ', this.lookupPropertyFunctionVarDeclaration(), ';\\n']);\n      this.decorators.push('return fn;');\n\n      if (asObject) {\n        this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);\n      } else {\n        this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\\n');\n        this.decorators.push('}\\n');\n        this.decorators = this.decorators.merge();\n      }\n    } else {\n      this.decorators = undefined;\n    }\n\n    var fn = this.createFunctionContext(asObject);\n\n    if (!this.isChild) {\n      var ret = {\n        compiler: this.compilerInfo(),\n        main: fn\n      };\n\n      if (this.decorators) {\n        ret.main_d = this.decorators; // eslint-disable-line camelcase\n\n        ret.useDecorators = true;\n      }\n\n      var _context = this.context;\n      var programs = _context.programs;\n      var decorators = _context.decorators;\n\n      for (i = 0, l = programs.length; i < l; i++) {\n        if (programs[i]) {\n          ret[i] = programs[i];\n\n          if (decorators[i]) {\n            ret[i + '_d'] = decorators[i];\n            ret.useDecorators = true;\n          }\n        }\n      }\n\n      if (this.environment.usePartial) {\n        ret.usePartial = true;\n      }\n\n      if (this.options.data) {\n        ret.useData = true;\n      }\n\n      if (this.useDepths) {\n        ret.useDepths = true;\n      }\n\n      if (this.useBlockParams) {\n        ret.useBlockParams = true;\n      }\n\n      if (this.options.compat) {\n        ret.compat = true;\n      }\n\n      if (!asObject) {\n        ret.compiler = JSON.stringify(ret.compiler);\n        this.source.currentLocation = {\n          start: {\n            line: 1,\n            column: 0\n          }\n        };\n        ret = this.objectLiteral(ret);\n\n        if (options.srcName) {\n          ret = ret.toStringWithSourceMap({\n            file: options.destName\n          });\n          ret.map = ret.map && ret.map.toString();\n        } else {\n          ret = ret.toString();\n        }\n      } else {\n        ret.compilerOptions = this.options;\n      }\n\n      return ret;\n    } else {\n      return fn;\n    }\n  },\n  preamble: function preamble() {\n    // track the last context pushed into place to allow skipping the\n    // getContext opcode when it would be a noop\n    this.lastContext = 0;\n    this.source = new _codeGen2['default'](this.options.srcName);\n    this.decorators = new _codeGen2['default'](this.options.srcName);\n  },\n  createFunctionContext: function createFunctionContext(asObject) {\n    // istanbul ignore next\n    var _this = this;\n\n    var varDeclarations = '';\n    var locals = this.stackVars.concat(this.registers.list);\n\n    if (locals.length > 0) {\n      varDeclarations += ', ' + locals.join(', ');\n    } // Generate minimizer alias mappings\n    //\n    // When using true SourceNodes, this will update all references to the given alias\n    // as the source nodes are reused in situ. For the non-source node compilation mode,\n    // aliases will not be used, but this case is already being run on the client and\n    // we aren't concern about minimizing the template size.\n\n\n    var aliasCount = 0;\n    Object.keys(this.aliases).forEach(function (alias) {\n      var node = _this.aliases[alias];\n\n      if (node.children && node.referenceCount > 1) {\n        varDeclarations += ', alias' + ++aliasCount + '=' + alias;\n        node.children[0] = 'alias' + aliasCount;\n      }\n    });\n\n    if (this.lookupPropertyFunctionIsUsed) {\n      varDeclarations += ', ' + this.lookupPropertyFunctionVarDeclaration();\n    }\n\n    var params = ['container', 'depth0', 'helpers', 'partials', 'data'];\n\n    if (this.useBlockParams || this.useDepths) {\n      params.push('blockParams');\n    }\n\n    if (this.useDepths) {\n      params.push('depths');\n    } // Perform a second pass over the output to merge content when possible\n\n\n    var source = this.mergeSource(varDeclarations);\n\n    if (asObject) {\n      params.push(source);\n      return Function.apply(this, params);\n    } else {\n      return this.source.wrap(['function(', params.join(','), ') {\\n  ', source, '}']);\n    }\n  },\n  mergeSource: function mergeSource(varDeclarations) {\n    var isSimple = this.environment.isSimple,\n        appendOnly = !this.forceBuffer,\n        appendFirst = undefined,\n        sourceSeen = undefined,\n        bufferStart = undefined,\n        bufferEnd = undefined;\n    this.source.each(function (line) {\n      if (line.appendToBuffer) {\n        if (bufferStart) {\n          line.prepend('  + ');\n        } else {\n          bufferStart = line;\n        }\n\n        bufferEnd = line;\n      } else {\n        if (bufferStart) {\n          if (!sourceSeen) {\n            appendFirst = true;\n          } else {\n            bufferStart.prepend('buffer += ');\n          }\n\n          bufferEnd.add(';');\n          bufferStart = bufferEnd = undefined;\n        }\n\n        sourceSeen = true;\n\n        if (!isSimple) {\n          appendOnly = false;\n        }\n      }\n    });\n\n    if (appendOnly) {\n      if (bufferStart) {\n        bufferStart.prepend('return ');\n        bufferEnd.add(';');\n      } else if (!sourceSeen) {\n        this.source.push('return \"\";');\n      }\n    } else {\n      varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());\n\n      if (bufferStart) {\n        bufferStart.prepend('return buffer + ');\n        bufferEnd.add(';');\n      } else {\n        this.source.push('return buffer;');\n      }\n    }\n\n    if (varDeclarations) {\n      this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\\n'));\n    }\n\n    return this.source.merge();\n  },\n  lookupPropertyFunctionVarDeclaration: function lookupPropertyFunctionVarDeclaration() {\n    return '\\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\\n          return parent[propertyName];\\n        }\\n        return undefined\\n    }\\n    '.trim();\n  },\n  // [blockValue]\n  //\n  // On stack, before: hash, inverse, program, value\n  // On stack, after: return value of blockHelperMissing\n  //\n  // The purpose of this opcode is to take a block of the form\n  // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and\n  // replace it on the stack with the result of properly\n  // invoking blockHelperMissing.\n  blockValue: function blockValue(name) {\n    var blockHelperMissing = this.aliasable('container.hooks.blockHelperMissing'),\n        params = [this.contextName(0)];\n    this.setupHelperArgs(name, 0, params);\n    var blockName = this.popStack();\n    params.splice(1, 0, blockName);\n    this.push(this.source.functionCall(blockHelperMissing, 'call', params));\n  },\n  // [ambiguousBlockValue]\n  //\n  // On stack, before: hash, inverse, program, value\n  // Compiler value, before: lastHelper=value of last found helper, if any\n  // On stack, after, if no lastHelper: same as [blockValue]\n  // On stack, after, if lastHelper: value\n  ambiguousBlockValue: function ambiguousBlockValue() {\n    // We're being a bit cheeky and reusing the options value from the prior exec\n    var blockHelperMissing = this.aliasable('container.hooks.blockHelperMissing'),\n        params = [this.contextName(0)];\n    this.setupHelperArgs('', 0, params, true);\n    this.flushInline();\n    var current = this.topStack();\n    params.splice(1, 0, current);\n    this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);\n  },\n  // [appendContent]\n  //\n  // On stack, before: ...\n  // On stack, after: ...\n  //\n  // Appends the string value of `content` to the current buffer\n  appendContent: function appendContent(content) {\n    if (this.pendingContent) {\n      content = this.pendingContent + content;\n    } else {\n      this.pendingLocation = this.source.currentLocation;\n    }\n\n    this.pendingContent = content;\n  },\n  // [append]\n  //\n  // On stack, before: value, ...\n  // On stack, after: ...\n  //\n  // Coerces `value` to a String and appends it to the current buffer.\n  //\n  // If `value` is truthy, or 0, it is coerced into a string and appended\n  // Otherwise, the empty string is appended\n  append: function append() {\n    if (this.isInline()) {\n      this.replaceStack(function (current) {\n        return [' != null ? ', current, ' : \"\"'];\n      });\n      this.pushSource(this.appendToBuffer(this.popStack()));\n    } else {\n      var local = this.popStack();\n      this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);\n\n      if (this.environment.isSimple) {\n        this.pushSource(['else { ', this.appendToBuffer(\"''\", undefined, true), ' }']);\n      }\n    }\n  },\n  // [appendEscaped]\n  //\n  // On stack, before: value, ...\n  // On stack, after: ...\n  //\n  // Escape `value` and append it to the buffer\n  appendEscaped: function appendEscaped() {\n    this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));\n  },\n  // [getContext]\n  //\n  // On stack, before: ...\n  // On stack, after: ...\n  // Compiler value, after: lastContext=depth\n  //\n  // Set the value of the `lastContext` compiler value to the depth\n  getContext: function getContext(depth) {\n    this.lastContext = depth;\n  },\n  // [pushContext]\n  //\n  // On stack, before: ...\n  // On stack, after: currentContext, ...\n  //\n  // Pushes the value of the current context onto the stack.\n  pushContext: function pushContext() {\n    this.pushStackLiteral(this.contextName(this.lastContext));\n  },\n  // [lookupOnContext]\n  //\n  // On stack, before: ...\n  // On stack, after: currentContext[name], ...\n  //\n  // Looks up the value of `name` on the current context and pushes\n  // it onto the stack.\n  lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {\n    var i = 0;\n\n    if (!scoped && this.options.compat && !this.lastContext) {\n      // The depthed query is expected to handle the undefined logic for the root level that\n      // is implemented below, so we evaluate that directly in compat mode\n      this.push(this.depthedLookup(parts[i++]));\n    } else {\n      this.pushContext();\n    }\n\n    this.resolvePath('context', parts, i, falsy, strict);\n  },\n  // [lookupBlockParam]\n  //\n  // On stack, before: ...\n  // On stack, after: blockParam[name], ...\n  //\n  // Looks up the value of `parts` on the given block param and pushes\n  // it onto the stack.\n  lookupBlockParam: function lookupBlockParam(blockParamId, parts) {\n    this.useBlockParams = true;\n    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);\n    this.resolvePath('context', parts, 1);\n  },\n  // [lookupData]\n  //\n  // On stack, before: ...\n  // On stack, after: data, ...\n  //\n  // Push the data lookup operator\n  lookupData: function lookupData(depth, parts, strict) {\n    if (!depth) {\n      this.pushStackLiteral('data');\n    } else {\n      this.pushStackLiteral('container.data(data, ' + depth + ')');\n    }\n\n    this.resolvePath('data', parts, 0, true, strict);\n  },\n  resolvePath: function resolvePath(type, parts, i, falsy, strict) {\n    // istanbul ignore next\n    var _this2 = this;\n\n    if (this.options.strict || this.options.assumeObjects) {\n      this.push(strictLookup(this.options.strict && strict, this, parts, type));\n      return;\n    }\n\n    var len = parts.length;\n\n    for (; i < len; i++) {\n      /* eslint-disable no-loop-func */\n      this.replaceStack(function (current) {\n        var lookup = _this2.nameLookup(current, parts[i], type); // We want to ensure that zero and false are handled properly if the context (falsy flag)\n        // needs to have the special handling for these values.\n\n\n        if (!falsy) {\n          return [' != null ? ', lookup, ' : ', current];\n        } else {\n          // Otherwise we can use generic falsy handling\n          return [' && ', lookup];\n        }\n      });\n      /* eslint-enable no-loop-func */\n    }\n  },\n  // [resolvePossibleLambda]\n  //\n  // On stack, before: value, ...\n  // On stack, after: resolved value, ...\n  //\n  // If the `value` is a lambda, replace it on the stack by\n  // the return value of the lambda\n  resolvePossibleLambda: function resolvePossibleLambda() {\n    this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);\n  },\n  // [pushStringParam]\n  //\n  // On stack, before: ...\n  // On stack, after: string, currentContext, ...\n  //\n  // This opcode is designed for use in string mode, which\n  // provides the string value of a parameter along with its\n  // depth rather than resolving it immediately.\n  pushStringParam: function pushStringParam(string, type) {\n    this.pushContext();\n    this.pushString(type); // If it's a subexpression, the string result\n    // will be pushed after this opcode.\n\n    if (type !== 'SubExpression') {\n      if (typeof string === 'string') {\n        this.pushString(string);\n      } else {\n        this.pushStackLiteral(string);\n      }\n    }\n  },\n  emptyHash: function emptyHash(omitEmpty) {\n    if (this.trackIds) {\n      this.push('{}'); // hashIds\n    }\n\n    if (this.stringParams) {\n      this.push('{}'); // hashContexts\n\n      this.push('{}'); // hashTypes\n    }\n\n    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');\n  },\n  pushHash: function pushHash() {\n    if (this.hash) {\n      this.hashes.push(this.hash);\n    }\n\n    this.hash = {\n      values: {},\n      types: [],\n      contexts: [],\n      ids: []\n    };\n  },\n  popHash: function popHash() {\n    var hash = this.hash;\n    this.hash = this.hashes.pop();\n\n    if (this.trackIds) {\n      this.push(this.objectLiteral(hash.ids));\n    }\n\n    if (this.stringParams) {\n      this.push(this.objectLiteral(hash.contexts));\n      this.push(this.objectLiteral(hash.types));\n    }\n\n    this.push(this.objectLiteral(hash.values));\n  },\n  // [pushString]\n  //\n  // On stack, before: ...\n  // On stack, after: quotedString(string), ...\n  //\n  // Push a quoted version of `string` onto the stack\n  pushString: function pushString(string) {\n    this.pushStackLiteral(this.quotedString(string));\n  },\n  // [pushLiteral]\n  //\n  // On stack, before: ...\n  // On stack, after: value, ...\n  //\n  // Pushes a value onto the stack. This operation prevents\n  // the compiler from creating a temporary variable to hold\n  // it.\n  pushLiteral: function pushLiteral(value) {\n    this.pushStackLiteral(value);\n  },\n  // [pushProgram]\n  //\n  // On stack, before: ...\n  // On stack, after: program(guid), ...\n  //\n  // Push a program expression onto the stack. This takes\n  // a compile-time guid and converts it into a runtime-accessible\n  // expression.\n  pushProgram: function pushProgram(guid) {\n    if (guid != null) {\n      this.pushStackLiteral(this.programExpression(guid));\n    } else {\n      this.pushStackLiteral(null);\n    }\n  },\n  // [registerDecorator]\n  //\n  // On stack, before: hash, program, params..., ...\n  // On stack, after: ...\n  //\n  // Pops off the decorator's parameters, invokes the decorator,\n  // and inserts the decorator into the decorators list.\n  registerDecorator: function registerDecorator(paramSize, name) {\n    var foundDecorator = this.nameLookup('decorators', name, 'decorator'),\n        options = this.setupHelperArgs(name, paramSize);\n    this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);\n  },\n  // [invokeHelper]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of helper invocation\n  //\n  // Pops off the helper's parameters, invokes the helper,\n  // and pushes the helper's return value onto the stack.\n  //\n  // If the helper is not found, `helperMissing` is called.\n  invokeHelper: function invokeHelper(paramSize, name, isSimple) {\n    var nonHelper = this.popStack(),\n        helper = this.setupHelper(paramSize, name);\n    var possibleFunctionCalls = [];\n\n    if (isSimple) {\n      // direct call to helper\n      possibleFunctionCalls.push(helper.name);\n    } // call a function from the input object\n\n\n    possibleFunctionCalls.push(nonHelper);\n\n    if (!this.options.strict) {\n      possibleFunctionCalls.push(this.aliasable('container.hooks.helperMissing'));\n    }\n\n    var functionLookupCode = ['(', this.itemsSeparatedBy(possibleFunctionCalls, '||'), ')'];\n    var functionCall = this.source.functionCall(functionLookupCode, 'call', helper.callParams);\n    this.push(functionCall);\n  },\n  itemsSeparatedBy: function itemsSeparatedBy(items, separator) {\n    var result = [];\n    result.push(items[0]);\n\n    for (var i = 1; i < items.length; i++) {\n      result.push(separator, items[i]);\n    }\n\n    return result;\n  },\n  // [invokeKnownHelper]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of helper invocation\n  //\n  // This operation is used when the helper is known to exist,\n  // so a `helperMissing` fallback is not required.\n  invokeKnownHelper: function invokeKnownHelper(paramSize, name) {\n    var helper = this.setupHelper(paramSize, name);\n    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));\n  },\n  // [invokeAmbiguous]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of disambiguation\n  //\n  // This operation is used when an expression like `{{foo}}`\n  // is provided, but we don't know at compile-time whether it\n  // is a helper or a path.\n  //\n  // This operation emits more code than the other options,\n  // and can be avoided by passing the `knownHelpers` and\n  // `knownHelpersOnly` flags at compile-time.\n  invokeAmbiguous: function invokeAmbiguous(name, helperCall) {\n    this.useRegister('helper');\n    var nonHelper = this.popStack();\n    this.emptyHash();\n    var helper = this.setupHelper(0, name, helperCall);\n    var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');\n    var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];\n\n    if (!this.options.strict) {\n      lookup[0] = '(helper = ';\n      lookup.push(' != null ? helper : ', this.aliasable('container.hooks.helperMissing'));\n    }\n\n    this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('\"function\"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);\n  },\n  // [invokePartial]\n  //\n  // On stack, before: context, ...\n  // On stack after: result of partial invocation\n  //\n  // This operation pops off a context, invokes a partial with that context,\n  // and pushes the result of the invocation back.\n  invokePartial: function invokePartial(isDynamic, name, indent) {\n    var params = [],\n        options = this.setupParams(name, 1, params);\n\n    if (isDynamic) {\n      name = this.popStack();\n      delete options.name;\n    }\n\n    if (indent) {\n      options.indent = JSON.stringify(indent);\n    }\n\n    options.helpers = 'helpers';\n    options.partials = 'partials';\n    options.decorators = 'container.decorators';\n\n    if (!isDynamic) {\n      params.unshift(this.nameLookup('partials', name, 'partial'));\n    } else {\n      params.unshift(name);\n    }\n\n    if (this.options.compat) {\n      options.depths = 'depths';\n    }\n\n    options = this.objectLiteral(options);\n    params.push(options);\n    this.push(this.source.functionCall('container.invokePartial', '', params));\n  },\n  // [assignToHash]\n  //\n  // On stack, before: value, ..., hash, ...\n  // On stack, after: ..., hash, ...\n  //\n  // Pops a value off the stack and assigns it to the current hash\n  assignToHash: function assignToHash(key) {\n    var value = this.popStack(),\n        context = undefined,\n        type = undefined,\n        id = undefined;\n\n    if (this.trackIds) {\n      id = this.popStack();\n    }\n\n    if (this.stringParams) {\n      type = this.popStack();\n      context = this.popStack();\n    }\n\n    var hash = this.hash;\n\n    if (context) {\n      hash.contexts[key] = context;\n    }\n\n    if (type) {\n      hash.types[key] = type;\n    }\n\n    if (id) {\n      hash.ids[key] = id;\n    }\n\n    hash.values[key] = value;\n  },\n  pushId: function pushId(type, name, child) {\n    if (type === 'BlockParam') {\n      this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));\n    } else if (type === 'PathExpression') {\n      this.pushString(name);\n    } else if (type === 'SubExpression') {\n      this.pushStackLiteral('true');\n    } else {\n      this.pushStackLiteral('null');\n    }\n  },\n  // HELPERS\n  compiler: JavaScriptCompiler,\n  compileChildren: function compileChildren(environment, options) {\n    var children = environment.children,\n        child = undefined,\n        compiler = undefined;\n\n    for (var i = 0, l = children.length; i < l; i++) {\n      child = children[i];\n      compiler = new this.compiler(); // eslint-disable-line new-cap\n\n      var existing = this.matchExistingProgram(child);\n\n      if (existing == null) {\n        this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children\n\n        var index = this.context.programs.length;\n        child.index = index;\n        child.name = 'program' + index;\n        this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);\n        this.context.decorators[index] = compiler.decorators;\n        this.context.environments[index] = child;\n        this.useDepths = this.useDepths || compiler.useDepths;\n        this.useBlockParams = this.useBlockParams || compiler.useBlockParams;\n        child.useDepths = this.useDepths;\n        child.useBlockParams = this.useBlockParams;\n      } else {\n        child.index = existing.index;\n        child.name = 'program' + existing.index;\n        this.useDepths = this.useDepths || existing.useDepths;\n        this.useBlockParams = this.useBlockParams || existing.useBlockParams;\n      }\n    }\n  },\n  matchExistingProgram: function matchExistingProgram(child) {\n    for (var i = 0, len = this.context.environments.length; i < len; i++) {\n      var environment = this.context.environments[i];\n\n      if (environment && environment.equals(child)) {\n        return environment;\n      }\n    }\n  },\n  programExpression: function programExpression(guid) {\n    var child = this.environment.children[guid],\n        programParams = [child.index, 'data', child.blockParams];\n\n    if (this.useBlockParams || this.useDepths) {\n      programParams.push('blockParams');\n    }\n\n    if (this.useDepths) {\n      programParams.push('depths');\n    }\n\n    return 'container.program(' + programParams.join(', ') + ')';\n  },\n  useRegister: function useRegister(name) {\n    if (!this.registers[name]) {\n      this.registers[name] = true;\n      this.registers.list.push(name);\n    }\n  },\n  push: function push(expr) {\n    if (!(expr instanceof Literal)) {\n      expr = this.source.wrap(expr);\n    }\n\n    this.inlineStack.push(expr);\n    return expr;\n  },\n  pushStackLiteral: function pushStackLiteral(item) {\n    this.push(new Literal(item));\n  },\n  pushSource: function pushSource(source) {\n    if (this.pendingContent) {\n      this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));\n      this.pendingContent = undefined;\n    }\n\n    if (source) {\n      this.source.push(source);\n    }\n  },\n  replaceStack: function replaceStack(callback) {\n    var prefix = ['('],\n        stack = undefined,\n        createdStack = undefined,\n        usedLiteral = undefined;\n    /* istanbul ignore next */\n\n    if (!this.isInline()) {\n      throw new _exception2['default']('replaceStack on non-inline');\n    } // We want to merge the inline statement into the replacement statement via ','\n\n\n    var top = this.popStack(true);\n\n    if (top instanceof Literal) {\n      // Literals do not need to be inlined\n      stack = [top.value];\n      prefix = ['(', stack];\n      usedLiteral = true;\n    } else {\n      // Get or create the current stack name for use by the inline\n      createdStack = true;\n\n      var _name = this.incrStack();\n\n      prefix = ['((', this.push(_name), ' = ', top, ')'];\n      stack = this.topStack();\n    }\n\n    var item = callback.call(this, stack);\n\n    if (!usedLiteral) {\n      this.popStack();\n    }\n\n    if (createdStack) {\n      this.stackSlot--;\n    }\n\n    this.push(prefix.concat(item, ')'));\n  },\n  incrStack: function incrStack() {\n    this.stackSlot++;\n\n    if (this.stackSlot > this.stackVars.length) {\n      this.stackVars.push('stack' + this.stackSlot);\n    }\n\n    return this.topStackName();\n  },\n  topStackName: function topStackName() {\n    return 'stack' + this.stackSlot;\n  },\n  flushInline: function flushInline() {\n    var inlineStack = this.inlineStack;\n    this.inlineStack = [];\n\n    for (var i = 0, len = inlineStack.length; i < len; i++) {\n      var entry = inlineStack[i];\n      /* istanbul ignore if */\n\n      if (entry instanceof Literal) {\n        this.compileStack.push(entry);\n      } else {\n        var stack = this.incrStack();\n        this.pushSource([stack, ' = ', entry, ';']);\n        this.compileStack.push(stack);\n      }\n    }\n  },\n  isInline: function isInline() {\n    return this.inlineStack.length;\n  },\n  popStack: function popStack(wrapped) {\n    var inline = this.isInline(),\n        item = (inline ? this.inlineStack : this.compileStack).pop();\n\n    if (!wrapped && item instanceof Literal) {\n      return item.value;\n    } else {\n      if (!inline) {\n        /* istanbul ignore next */\n        if (!this.stackSlot) {\n          throw new _exception2['default']('Invalid stack pop');\n        }\n\n        this.stackSlot--;\n      }\n\n      return item;\n    }\n  },\n  topStack: function topStack() {\n    var stack = this.isInline() ? this.inlineStack : this.compileStack,\n        item = stack[stack.length - 1];\n    /* istanbul ignore if */\n\n    if (item instanceof Literal) {\n      return item.value;\n    } else {\n      return item;\n    }\n  },\n  contextName: function contextName(context) {\n    if (this.useDepths && context) {\n      return 'depths[' + context + ']';\n    } else {\n      return 'depth' + context;\n    }\n  },\n  quotedString: function quotedString(str) {\n    return this.source.quotedString(str);\n  },\n  objectLiteral: function objectLiteral(obj) {\n    return this.source.objectLiteral(obj);\n  },\n  aliasable: function aliasable(name) {\n    var ret = this.aliases[name];\n\n    if (ret) {\n      ret.referenceCount++;\n      return ret;\n    }\n\n    ret = this.aliases[name] = this.source.wrap(name);\n    ret.aliasable = true;\n    ret.referenceCount = 1;\n    return ret;\n  },\n  setupHelper: function setupHelper(paramSize, name, blockHelper) {\n    var params = [],\n        paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);\n    var foundHelper = this.nameLookup('helpers', name, 'helper'),\n        callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : (container.nullContext || {})');\n    return {\n      params: params,\n      paramsInit: paramsInit,\n      name: foundHelper,\n      callParams: [callContext].concat(params)\n    };\n  },\n  setupParams: function setupParams(helper, paramSize, params) {\n    var options = {},\n        contexts = [],\n        types = [],\n        ids = [],\n        objectArgs = !params,\n        param = undefined;\n\n    if (objectArgs) {\n      params = [];\n    }\n\n    options.name = this.quotedString(helper);\n    options.hash = this.popStack();\n\n    if (this.trackIds) {\n      options.hashIds = this.popStack();\n    }\n\n    if (this.stringParams) {\n      options.hashTypes = this.popStack();\n      options.hashContexts = this.popStack();\n    }\n\n    var inverse = this.popStack(),\n        program = this.popStack(); // Avoid setting fn and inverse if neither are set. This allows\n    // helpers to do a check for `if (options.fn)`\n\n    if (program || inverse) {\n      options.fn = program || 'container.noop';\n      options.inverse = inverse || 'container.noop';\n    } // The parameters go on to the stack in order (making sure that they are evaluated in order)\n    // so we need to pop them off the stack in reverse order\n\n\n    var i = paramSize;\n\n    while (i--) {\n      param = this.popStack();\n      params[i] = param;\n\n      if (this.trackIds) {\n        ids[i] = this.popStack();\n      }\n\n      if (this.stringParams) {\n        types[i] = this.popStack();\n        contexts[i] = this.popStack();\n      }\n    }\n\n    if (objectArgs) {\n      options.args = this.source.generateArray(params);\n    }\n\n    if (this.trackIds) {\n      options.ids = this.source.generateArray(ids);\n    }\n\n    if (this.stringParams) {\n      options.types = this.source.generateArray(types);\n      options.contexts = this.source.generateArray(contexts);\n    }\n\n    if (this.options.data) {\n      options.data = 'data';\n    }\n\n    if (this.useBlockParams) {\n      options.blockParams = 'blockParams';\n    }\n\n    return options;\n  },\n  setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {\n    var options = this.setupParams(helper, paramSize, params);\n    options.loc = JSON.stringify(this.source.currentLocation);\n    options = this.objectLiteral(options);\n\n    if (useRegister) {\n      this.useRegister('options');\n      params.push('options');\n      return ['options=', options];\n    } else if (params) {\n      params.push(options);\n      return '';\n    } else {\n      return options;\n    }\n  }\n};\n\n(function () {\n  var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');\n  var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};\n\n  for (var i = 0, l = reservedWords.length; i < l; i++) {\n    compilerWords[reservedWords[i]] = true;\n  }\n})();\n/**\n * @deprecated May be removed in the next major version\n */\n\n\nJavaScriptCompiler.isValidJavaScriptVariableName = function (name) {\n  return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);\n};\n\nfunction strictLookup(requireTerminal, compiler, parts, type) {\n  var stack = compiler.popStack(),\n      i = 0,\n      len = parts.length;\n\n  if (requireTerminal) {\n    len--;\n  }\n\n  for (; i < len; i++) {\n    stack = compiler.nameLookup(stack, parts[i], type);\n  }\n\n  if (requireTerminal) {\n    return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ', ', JSON.stringify(compiler.source.currentLocation), ' )'];\n  } else {\n    return stack;\n  }\n}\n\nexports['default'] = JavaScriptCompiler;\nmodule.exports = exports['default'];","map":{"version":3,"mappings":"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","names":["Literal","value","JavaScriptCompiler","prototype","nameLookup","parent","name","internalNameLookup","depthedLookup","aliasable","JSON","stringify","compilerInfo","revision","versions","_base","appendToBuffer","source","location","explicit","_utils","wrap","environment","isSimple","initializeBuffer","quotedString","lookupPropertyFunctionIsUsed","compile","options","context","asObject","stringParams","trackIds","precompile","isChild","decorators","programs","environments","preamble","stackSlot","stackVars","aliases","registers","list","hashes","compileStack","inlineStack","blockParams","compileChildren","useDepths","useDecorators","compat","useBlockParams","opcodes","opcode","firstLoc","i","l","length","currentLocation","loc","apply","args","pushSource","isEmpty","prepend","lookupPropertyFunctionVarDeclaration","push","Function","merge","undefined","fn","createFunctionContext","ret","compiler","main","main_d","usePartial","data","useData","start","line","column","objectLiteral","srcName","toStringWithSourceMap","file","destName","map","toString","compilerOptions","lastContext","varDeclarations","locals","concat","join","aliasCount","Object","keys","forEach","node","_this","alias","children","referenceCount","params","mergeSource","appendOnly","forceBuffer","appendFirst","sourceSeen","bufferStart","bufferEnd","each","add","substring","trim","blockValue","blockHelperMissing","contextName","setupHelperArgs","blockName","popStack","splice","functionCall","ambiguousBlockValue","flushInline","current","topStack","lastHelper","appendContent","content","pendingContent","pendingLocation","append","isInline","replaceStack","local","appendEscaped","getContext","depth","pushContext","pushStackLiteral","lookupOnContext","parts","falsy","strict","scoped","resolvePath","lookupBlockParam","blockParamId","lookupData","type","assumeObjects","strictLookup","len","lookup","_this2","resolvePossibleLambda","pushStringParam","string","pushString","emptyHash","omitEmpty","pushHash","hash","values","types","contexts","ids","popHash","pop","pushLiteral","pushProgram","guid","programExpression","registerDecorator","paramSize","foundDecorator","invokeHelper","nonHelper","helper","setupHelper","possibleFunctionCalls","functionLookupCode","itemsSeparatedBy","callParams","items","separator","result","invokeKnownHelper","invokeAmbiguous","helperCall","useRegister","helperName","paramsInit","invokePartial","isDynamic","indent","setupParams","helpers","partials","unshift","depths","assignToHash","key","id","pushId","child","existing","matchExistingProgram","index","equals","programParams","expr","item","callback","prefix","stack","createdStack","usedLiteral","top","_name","incrStack","call","topStackName","entry","wrapped","inline","str","obj","blockHelper","foundHelper","callContext","objectArgs","param","hashIds","hashTypes","hashContexts","inverse","program","generateArray","reservedWords","split","compilerWords","RESERVED_WORDS","isValidJavaScriptVariableName","test","requireTerminal"],"sources":["../../../../lib/handlebars/compiler/javascript-compiler.js"],"sourcesContent":["import { COMPILER_REVISION, REVISION_CHANGES } from '../base';\nimport Exception from '../exception';\nimport { isArray } from '../utils';\nimport CodeGen from './code-gen';\n\nfunction Literal(value) {\n  this.value = value;\n}\n\nfunction JavaScriptCompiler() {}\n\nJavaScriptCompiler.prototype = {\n  // PUBLIC API: You can override these methods in a subclass to provide\n  // alternative compiled forms for name lookup and buffering semantics\n  nameLookup: function(parent, name /*,  type */) {\n    return this.internalNameLookup(parent, name);\n  },\n  depthedLookup: function(name) {\n    return [\n      this.aliasable('container.lookup'),\n      '(depths, ',\n      JSON.stringify(name),\n      ')'\n    ];\n  },\n\n  compilerInfo: function() {\n    const revision = COMPILER_REVISION,\n      versions = REVISION_CHANGES[revision];\n    return [revision, versions];\n  },\n\n  appendToBuffer: function(source, location, explicit) {\n    // Force a source as this simplifies the merge logic.\n    if (!isArray(source)) {\n      source = [source];\n    }\n    source = this.source.wrap(source, location);\n\n    if (this.environment.isSimple) {\n      return ['return ', source, ';'];\n    } else if (explicit) {\n      // This is a case where the buffer operation occurs as a child of another\n      // construct, generally braces. We have to explicitly output these buffer\n      // operations to ensure that the emitted code goes in the correct location.\n      return ['buffer += ', source, ';'];\n    } else {\n      source.appendToBuffer = true;\n      return source;\n    }\n  },\n\n  initializeBuffer: function() {\n    return this.quotedString('');\n  },\n  // END PUBLIC API\n  internalNameLookup: function(parent, name) {\n    this.lookupPropertyFunctionIsUsed = true;\n    return ['lookupProperty(', parent, ',', JSON.stringify(name), ')'];\n  },\n\n  lookupPropertyFunctionIsUsed: false,\n\n  compile: function(environment, options, context, asObject) {\n    this.environment = environment;\n    this.options = options;\n    this.stringParams = this.options.stringParams;\n    this.trackIds = this.options.trackIds;\n    this.precompile = !asObject;\n\n    this.name = this.environment.name;\n    this.isChild = !!context;\n    this.context = context || {\n      decorators: [],\n      programs: [],\n      environments: []\n    };\n\n    this.preamble();\n\n    this.stackSlot = 0;\n    this.stackVars = [];\n    this.aliases = {};\n    this.registers = { list: [] };\n    this.hashes = [];\n    this.compileStack = [];\n    this.inlineStack = [];\n    this.blockParams = [];\n\n    this.compileChildren(environment, options);\n\n    this.useDepths =\n      this.useDepths ||\n      environment.useDepths ||\n      environment.useDecorators ||\n      this.options.compat;\n    this.useBlockParams = this.useBlockParams || environment.useBlockParams;\n\n    let opcodes = environment.opcodes,\n      opcode,\n      firstLoc,\n      i,\n      l;\n\n    for (i = 0, l = opcodes.length; i < l; i++) {\n      opcode = opcodes[i];\n\n      this.source.currentLocation = opcode.loc;\n      firstLoc = firstLoc || opcode.loc;\n      this[opcode.opcode].apply(this, opcode.args);\n    }\n\n    // Flush any trailing content that might be pending.\n    this.source.currentLocation = firstLoc;\n    this.pushSource('');\n\n    /* istanbul ignore next */\n    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {\n      throw new Exception('Compile completed with content left on stack');\n    }\n\n    if (!this.decorators.isEmpty()) {\n      this.useDecorators = true;\n\n      this.decorators.prepend([\n        'var decorators = container.decorators, ',\n        this.lookupPropertyFunctionVarDeclaration(),\n        ';\\n'\n      ]);\n      this.decorators.push('return fn;');\n\n      if (asObject) {\n        this.decorators = Function.apply(this, [\n          'fn',\n          'props',\n          'container',\n          'depth0',\n          'data',\n          'blockParams',\n          'depths',\n          this.decorators.merge()\n        ]);\n      } else {\n        this.decorators.prepend(\n          'function(fn, props, container, depth0, data, blockParams, depths) {\\n'\n        );\n        this.decorators.push('}\\n');\n        this.decorators = this.decorators.merge();\n      }\n    } else {\n      this.decorators = undefined;\n    }\n\n    let fn = this.createFunctionContext(asObject);\n    if (!this.isChild) {\n      let ret = {\n        compiler: this.compilerInfo(),\n        main: fn\n      };\n\n      if (this.decorators) {\n        ret.main_d = this.decorators; // eslint-disable-line camelcase\n        ret.useDecorators = true;\n      }\n\n      let { programs, decorators } = this.context;\n      for (i = 0, l = programs.length; i < l; i++) {\n        if (programs[i]) {\n          ret[i] = programs[i];\n          if (decorators[i]) {\n            ret[i + '_d'] = decorators[i];\n            ret.useDecorators = true;\n          }\n        }\n      }\n\n      if (this.environment.usePartial) {\n        ret.usePartial = true;\n      }\n      if (this.options.data) {\n        ret.useData = true;\n      }\n      if (this.useDepths) {\n        ret.useDepths = true;\n      }\n      if (this.useBlockParams) {\n        ret.useBlockParams = true;\n      }\n      if (this.options.compat) {\n        ret.compat = true;\n      }\n\n      if (!asObject) {\n        ret.compiler = JSON.stringify(ret.compiler);\n\n        this.source.currentLocation = { start: { line: 1, column: 0 } };\n        ret = this.objectLiteral(ret);\n\n        if (options.srcName) {\n          ret = ret.toStringWithSourceMap({ file: options.destName });\n          ret.map = ret.map && ret.map.toString();\n        } else {\n          ret = ret.toString();\n        }\n      } else {\n        ret.compilerOptions = this.options;\n      }\n\n      return ret;\n    } else {\n      return fn;\n    }\n  },\n\n  preamble: function() {\n    // track the last context pushed into place to allow skipping the\n    // getContext opcode when it would be a noop\n    this.lastContext = 0;\n    this.source = new CodeGen(this.options.srcName);\n    this.decorators = new CodeGen(this.options.srcName);\n  },\n\n  createFunctionContext: function(asObject) {\n    let varDeclarations = '';\n\n    let locals = this.stackVars.concat(this.registers.list);\n    if (locals.length > 0) {\n      varDeclarations += ', ' + locals.join(', ');\n    }\n\n    // Generate minimizer alias mappings\n    //\n    // When using true SourceNodes, this will update all references to the given alias\n    // as the source nodes are reused in situ. For the non-source node compilation mode,\n    // aliases will not be used, but this case is already being run on the client and\n    // we aren't concern about minimizing the template size.\n    let aliasCount = 0;\n    Object.keys(this.aliases).forEach(alias => {\n      let node = this.aliases[alias];\n      if (node.children && node.referenceCount > 1) {\n        varDeclarations += ', alias' + ++aliasCount + '=' + alias;\n        node.children[0] = 'alias' + aliasCount;\n      }\n    });\n\n    if (this.lookupPropertyFunctionIsUsed) {\n      varDeclarations += ', ' + this.lookupPropertyFunctionVarDeclaration();\n    }\n\n    let params = ['container', 'depth0', 'helpers', 'partials', 'data'];\n\n    if (this.useBlockParams || this.useDepths) {\n      params.push('blockParams');\n    }\n    if (this.useDepths) {\n      params.push('depths');\n    }\n\n    // Perform a second pass over the output to merge content when possible\n    let source = this.mergeSource(varDeclarations);\n\n    if (asObject) {\n      params.push(source);\n\n      return Function.apply(this, params);\n    } else {\n      return this.source.wrap([\n        'function(',\n        params.join(','),\n        ') {\\n  ',\n        source,\n        '}'\n      ]);\n    }\n  },\n  mergeSource: function(varDeclarations) {\n    let isSimple = this.environment.isSimple,\n      appendOnly = !this.forceBuffer,\n      appendFirst,\n      sourceSeen,\n      bufferStart,\n      bufferEnd;\n    this.source.each(line => {\n      if (line.appendToBuffer) {\n        if (bufferStart) {\n          line.prepend('  + ');\n        } else {\n          bufferStart = line;\n        }\n        bufferEnd = line;\n      } else {\n        if (bufferStart) {\n          if (!sourceSeen) {\n            appendFirst = true;\n          } else {\n            bufferStart.prepend('buffer += ');\n          }\n          bufferEnd.add(';');\n          bufferStart = bufferEnd = undefined;\n        }\n\n        sourceSeen = true;\n        if (!isSimple) {\n          appendOnly = false;\n        }\n      }\n    });\n\n    if (appendOnly) {\n      if (bufferStart) {\n        bufferStart.prepend('return ');\n        bufferEnd.add(';');\n      } else if (!sourceSeen) {\n        this.source.push('return \"\";');\n      }\n    } else {\n      varDeclarations +=\n        ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());\n\n      if (bufferStart) {\n        bufferStart.prepend('return buffer + ');\n        bufferEnd.add(';');\n      } else {\n        this.source.push('return buffer;');\n      }\n    }\n\n    if (varDeclarations) {\n      this.source.prepend(\n        'var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\\n')\n      );\n    }\n\n    return this.source.merge();\n  },\n\n  lookupPropertyFunctionVarDeclaration: function() {\n    return `\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    `.trim();\n  },\n\n  // [blockValue]\n  //\n  // On stack, before: hash, inverse, program, value\n  // On stack, after: return value of blockHelperMissing\n  //\n  // The purpose of this opcode is to take a block of the form\n  // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and\n  // replace it on the stack with the result of properly\n  // invoking blockHelperMissing.\n  blockValue: function(name) {\n    let blockHelperMissing = this.aliasable(\n        'container.hooks.blockHelperMissing'\n      ),\n      params = [this.contextName(0)];\n    this.setupHelperArgs(name, 0, params);\n\n    let blockName = this.popStack();\n    params.splice(1, 0, blockName);\n\n    this.push(this.source.functionCall(blockHelperMissing, 'call', params));\n  },\n\n  // [ambiguousBlockValue]\n  //\n  // On stack, before: hash, inverse, program, value\n  // Compiler value, before: lastHelper=value of last found helper, if any\n  // On stack, after, if no lastHelper: same as [blockValue]\n  // On stack, after, if lastHelper: value\n  ambiguousBlockValue: function() {\n    // We're being a bit cheeky and reusing the options value from the prior exec\n    let blockHelperMissing = this.aliasable(\n        'container.hooks.blockHelperMissing'\n      ),\n      params = [this.contextName(0)];\n    this.setupHelperArgs('', 0, params, true);\n\n    this.flushInline();\n\n    let current = this.topStack();\n    params.splice(1, 0, current);\n\n    this.pushSource([\n      'if (!',\n      this.lastHelper,\n      ') { ',\n      current,\n      ' = ',\n      this.source.functionCall(blockHelperMissing, 'call', params),\n      '}'\n    ]);\n  },\n\n  // [appendContent]\n  //\n  // On stack, before: ...\n  // On stack, after: ...\n  //\n  // Appends the string value of `content` to the current buffer\n  appendContent: function(content) {\n    if (this.pendingContent) {\n      content = this.pendingContent + content;\n    } else {\n      this.pendingLocation = this.source.currentLocation;\n    }\n\n    this.pendingContent = content;\n  },\n\n  // [append]\n  //\n  // On stack, before: value, ...\n  // On stack, after: ...\n  //\n  // Coerces `value` to a String and appends it to the current buffer.\n  //\n  // If `value` is truthy, or 0, it is coerced into a string and appended\n  // Otherwise, the empty string is appended\n  append: function() {\n    if (this.isInline()) {\n      this.replaceStack(current => [' != null ? ', current, ' : \"\"']);\n\n      this.pushSource(this.appendToBuffer(this.popStack()));\n    } else {\n      let local = this.popStack();\n      this.pushSource([\n        'if (',\n        local,\n        ' != null) { ',\n        this.appendToBuffer(local, undefined, true),\n        ' }'\n      ]);\n      if (this.environment.isSimple) {\n        this.pushSource([\n          'else { ',\n          this.appendToBuffer(\"''\", undefined, true),\n          ' }'\n        ]);\n      }\n    }\n  },\n\n  // [appendEscaped]\n  //\n  // On stack, before: value, ...\n  // On stack, after: ...\n  //\n  // Escape `value` and append it to the buffer\n  appendEscaped: function() {\n    this.pushSource(\n      this.appendToBuffer([\n        this.aliasable('container.escapeExpression'),\n        '(',\n        this.popStack(),\n        ')'\n      ])\n    );\n  },\n\n  // [getContext]\n  //\n  // On stack, before: ...\n  // On stack, after: ...\n  // Compiler value, after: lastContext=depth\n  //\n  // Set the value of the `lastContext` compiler value to the depth\n  getContext: function(depth) {\n    this.lastContext = depth;\n  },\n\n  // [pushContext]\n  //\n  // On stack, before: ...\n  // On stack, after: currentContext, ...\n  //\n  // Pushes the value of the current context onto the stack.\n  pushContext: function() {\n    this.pushStackLiteral(this.contextName(this.lastContext));\n  },\n\n  // [lookupOnContext]\n  //\n  // On stack, before: ...\n  // On stack, after: currentContext[name], ...\n  //\n  // Looks up the value of `name` on the current context and pushes\n  // it onto the stack.\n  lookupOnContext: function(parts, falsy, strict, scoped) {\n    let i = 0;\n\n    if (!scoped && this.options.compat && !this.lastContext) {\n      // The depthed query is expected to handle the undefined logic for the root level that\n      // is implemented below, so we evaluate that directly in compat mode\n      this.push(this.depthedLookup(parts[i++]));\n    } else {\n      this.pushContext();\n    }\n\n    this.resolvePath('context', parts, i, falsy, strict);\n  },\n\n  // [lookupBlockParam]\n  //\n  // On stack, before: ...\n  // On stack, after: blockParam[name], ...\n  //\n  // Looks up the value of `parts` on the given block param and pushes\n  // it onto the stack.\n  lookupBlockParam: function(blockParamId, parts) {\n    this.useBlockParams = true;\n\n    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);\n    this.resolvePath('context', parts, 1);\n  },\n\n  // [lookupData]\n  //\n  // On stack, before: ...\n  // On stack, after: data, ...\n  //\n  // Push the data lookup operator\n  lookupData: function(depth, parts, strict) {\n    if (!depth) {\n      this.pushStackLiteral('data');\n    } else {\n      this.pushStackLiteral('container.data(data, ' + depth + ')');\n    }\n\n    this.resolvePath('data', parts, 0, true, strict);\n  },\n\n  resolvePath: function(type, parts, i, falsy, strict) {\n    if (this.options.strict || this.options.assumeObjects) {\n      this.push(strictLookup(this.options.strict && strict, this, parts, type));\n      return;\n    }\n\n    let len = parts.length;\n    for (; i < len; i++) {\n      /* eslint-disable no-loop-func */\n      this.replaceStack(current => {\n        let lookup = this.nameLookup(current, parts[i], type);\n        // We want to ensure that zero and false are handled properly if the context (falsy flag)\n        // needs to have the special handling for these values.\n        if (!falsy) {\n          return [' != null ? ', lookup, ' : ', current];\n        } else {\n          // Otherwise we can use generic falsy handling\n          return [' && ', lookup];\n        }\n      });\n      /* eslint-enable no-loop-func */\n    }\n  },\n\n  // [resolvePossibleLambda]\n  //\n  // On stack, before: value, ...\n  // On stack, after: resolved value, ...\n  //\n  // If the `value` is a lambda, replace it on the stack by\n  // the return value of the lambda\n  resolvePossibleLambda: function() {\n    this.push([\n      this.aliasable('container.lambda'),\n      '(',\n      this.popStack(),\n      ', ',\n      this.contextName(0),\n      ')'\n    ]);\n  },\n\n  // [pushStringParam]\n  //\n  // On stack, before: ...\n  // On stack, after: string, currentContext, ...\n  //\n  // This opcode is designed for use in string mode, which\n  // provides the string value of a parameter along with its\n  // depth rather than resolving it immediately.\n  pushStringParam: function(string, type) {\n    this.pushContext();\n    this.pushString(type);\n\n    // If it's a subexpression, the string result\n    // will be pushed after this opcode.\n    if (type !== 'SubExpression') {\n      if (typeof string === 'string') {\n        this.pushString(string);\n      } else {\n        this.pushStackLiteral(string);\n      }\n    }\n  },\n\n  emptyHash: function(omitEmpty) {\n    if (this.trackIds) {\n      this.push('{}'); // hashIds\n    }\n    if (this.stringParams) {\n      this.push('{}'); // hashContexts\n      this.push('{}'); // hashTypes\n    }\n    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');\n  },\n  pushHash: function() {\n    if (this.hash) {\n      this.hashes.push(this.hash);\n    }\n    this.hash = { values: {}, types: [], contexts: [], ids: [] };\n  },\n  popHash: function() {\n    let hash = this.hash;\n    this.hash = this.hashes.pop();\n\n    if (this.trackIds) {\n      this.push(this.objectLiteral(hash.ids));\n    }\n    if (this.stringParams) {\n      this.push(this.objectLiteral(hash.contexts));\n      this.push(this.objectLiteral(hash.types));\n    }\n\n    this.push(this.objectLiteral(hash.values));\n  },\n\n  // [pushString]\n  //\n  // On stack, before: ...\n  // On stack, after: quotedString(string), ...\n  //\n  // Push a quoted version of `string` onto the stack\n  pushString: function(string) {\n    this.pushStackLiteral(this.quotedString(string));\n  },\n\n  // [pushLiteral]\n  //\n  // On stack, before: ...\n  // On stack, after: value, ...\n  //\n  // Pushes a value onto the stack. This operation prevents\n  // the compiler from creating a temporary variable to hold\n  // it.\n  pushLiteral: function(value) {\n    this.pushStackLiteral(value);\n  },\n\n  // [pushProgram]\n  //\n  // On stack, before: ...\n  // On stack, after: program(guid), ...\n  //\n  // Push a program expression onto the stack. This takes\n  // a compile-time guid and converts it into a runtime-accessible\n  // expression.\n  pushProgram: function(guid) {\n    if (guid != null) {\n      this.pushStackLiteral(this.programExpression(guid));\n    } else {\n      this.pushStackLiteral(null);\n    }\n  },\n\n  // [registerDecorator]\n  //\n  // On stack, before: hash, program, params..., ...\n  // On stack, after: ...\n  //\n  // Pops off the decorator's parameters, invokes the decorator,\n  // and inserts the decorator into the decorators list.\n  registerDecorator(paramSize, name) {\n    let foundDecorator = this.nameLookup('decorators', name, 'decorator'),\n      options = this.setupHelperArgs(name, paramSize);\n\n    this.decorators.push([\n      'fn = ',\n      this.decorators.functionCall(foundDecorator, '', [\n        'fn',\n        'props',\n        'container',\n        options\n      ]),\n      ' || fn;'\n    ]);\n  },\n\n  // [invokeHelper]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of helper invocation\n  //\n  // Pops off the helper's parameters, invokes the helper,\n  // and pushes the helper's return value onto the stack.\n  //\n  // If the helper is not found, `helperMissing` is called.\n  invokeHelper: function(paramSize, name, isSimple) {\n    let nonHelper = this.popStack(),\n      helper = this.setupHelper(paramSize, name);\n\n    let possibleFunctionCalls = [];\n\n    if (isSimple) {\n      // direct call to helper\n      possibleFunctionCalls.push(helper.name);\n    }\n    // call a function from the input object\n    possibleFunctionCalls.push(nonHelper);\n    if (!this.options.strict) {\n      possibleFunctionCalls.push(\n        this.aliasable('container.hooks.helperMissing')\n      );\n    }\n\n    let functionLookupCode = [\n      '(',\n      this.itemsSeparatedBy(possibleFunctionCalls, '||'),\n      ')'\n    ];\n    let functionCall = this.source.functionCall(\n      functionLookupCode,\n      'call',\n      helper.callParams\n    );\n    this.push(functionCall);\n  },\n\n  itemsSeparatedBy: function(items, separator) {\n    let result = [];\n    result.push(items[0]);\n    for (let i = 1; i < items.length; i++) {\n      result.push(separator, items[i]);\n    }\n    return result;\n  },\n  // [invokeKnownHelper]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of helper invocation\n  //\n  // This operation is used when the helper is known to exist,\n  // so a `helperMissing` fallback is not required.\n  invokeKnownHelper: function(paramSize, name) {\n    let helper = this.setupHelper(paramSize, name);\n    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));\n  },\n\n  // [invokeAmbiguous]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of disambiguation\n  //\n  // This operation is used when an expression like `{{foo}}`\n  // is provided, but we don't know at compile-time whether it\n  // is a helper or a path.\n  //\n  // This operation emits more code than the other options,\n  // and can be avoided by passing the `knownHelpers` and\n  // `knownHelpersOnly` flags at compile-time.\n  invokeAmbiguous: function(name, helperCall) {\n    this.useRegister('helper');\n\n    let nonHelper = this.popStack();\n\n    this.emptyHash();\n    let helper = this.setupHelper(0, name, helperCall);\n\n    let helperName = (this.lastHelper = this.nameLookup(\n      'helpers',\n      name,\n      'helper'\n    ));\n\n    let lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];\n    if (!this.options.strict) {\n      lookup[0] = '(helper = ';\n      lookup.push(\n        ' != null ? helper : ',\n        this.aliasable('container.hooks.helperMissing')\n      );\n    }\n\n    this.push([\n      '(',\n      lookup,\n      helper.paramsInit ? ['),(', helper.paramsInit] : [],\n      '),',\n      '(typeof helper === ',\n      this.aliasable('\"function\"'),\n      ' ? ',\n      this.source.functionCall('helper', 'call', helper.callParams),\n      ' : helper))'\n    ]);\n  },\n\n  // [invokePartial]\n  //\n  // On stack, before: context, ...\n  // On stack after: result of partial invocation\n  //\n  // This operation pops off a context, invokes a partial with that context,\n  // and pushes the result of the invocation back.\n  invokePartial: function(isDynamic, name, indent) {\n    let params = [],\n      options = this.setupParams(name, 1, params);\n\n    if (isDynamic) {\n      name = this.popStack();\n      delete options.name;\n    }\n\n    if (indent) {\n      options.indent = JSON.stringify(indent);\n    }\n    options.helpers = 'helpers';\n    options.partials = 'partials';\n    options.decorators = 'container.decorators';\n\n    if (!isDynamic) {\n      params.unshift(this.nameLookup('partials', name, 'partial'));\n    } else {\n      params.unshift(name);\n    }\n\n    if (this.options.compat) {\n      options.depths = 'depths';\n    }\n    options = this.objectLiteral(options);\n    params.push(options);\n\n    this.push(this.source.functionCall('container.invokePartial', '', params));\n  },\n\n  // [assignToHash]\n  //\n  // On stack, before: value, ..., hash, ...\n  // On stack, after: ..., hash, ...\n  //\n  // Pops a value off the stack and assigns it to the current hash\n  assignToHash: function(key) {\n    let value = this.popStack(),\n      context,\n      type,\n      id;\n\n    if (this.trackIds) {\n      id = this.popStack();\n    }\n    if (this.stringParams) {\n      type = this.popStack();\n      context = this.popStack();\n    }\n\n    let hash = this.hash;\n    if (context) {\n      hash.contexts[key] = context;\n    }\n    if (type) {\n      hash.types[key] = type;\n    }\n    if (id) {\n      hash.ids[key] = id;\n    }\n    hash.values[key] = value;\n  },\n\n  pushId: function(type, name, child) {\n    if (type === 'BlockParam') {\n      this.pushStackLiteral(\n        'blockParams[' +\n          name[0] +\n          '].path[' +\n          name[1] +\n          ']' +\n          (child ? ' + ' + JSON.stringify('.' + child) : '')\n      );\n    } else if (type === 'PathExpression') {\n      this.pushString(name);\n    } else if (type === 'SubExpression') {\n      this.pushStackLiteral('true');\n    } else {\n      this.pushStackLiteral('null');\n    }\n  },\n\n  // HELPERS\n\n  compiler: JavaScriptCompiler,\n\n  compileChildren: function(environment, options) {\n    let children = environment.children,\n      child,\n      compiler;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      child = children[i];\n      compiler = new this.compiler(); // eslint-disable-line new-cap\n\n      let existing = this.matchExistingProgram(child);\n\n      if (existing == null) {\n        this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children\n        let index = this.context.programs.length;\n        child.index = index;\n        child.name = 'program' + index;\n        this.context.programs[index] = compiler.compile(\n          child,\n          options,\n          this.context,\n          !this.precompile\n        );\n        this.context.decorators[index] = compiler.decorators;\n        this.context.environments[index] = child;\n\n        this.useDepths = this.useDepths || compiler.useDepths;\n        this.useBlockParams = this.useBlockParams || compiler.useBlockParams;\n        child.useDepths = this.useDepths;\n        child.useBlockParams = this.useBlockParams;\n      } else {\n        child.index = existing.index;\n        child.name = 'program' + existing.index;\n\n        this.useDepths = this.useDepths || existing.useDepths;\n        this.useBlockParams = this.useBlockParams || existing.useBlockParams;\n      }\n    }\n  },\n  matchExistingProgram: function(child) {\n    for (let i = 0, len = this.context.environments.length; i < len; i++) {\n      let environment = this.context.environments[i];\n      if (environment && environment.equals(child)) {\n        return environment;\n      }\n    }\n  },\n\n  programExpression: function(guid) {\n    let child = this.environment.children[guid],\n      programParams = [child.index, 'data', child.blockParams];\n\n    if (this.useBlockParams || this.useDepths) {\n      programParams.push('blockParams');\n    }\n    if (this.useDepths) {\n      programParams.push('depths');\n    }\n\n    return 'container.program(' + programParams.join(', ') + ')';\n  },\n\n  useRegister: function(name) {\n    if (!this.registers[name]) {\n      this.registers[name] = true;\n      this.registers.list.push(name);\n    }\n  },\n\n  push: function(expr) {\n    if (!(expr instanceof Literal)) {\n      expr = this.source.wrap(expr);\n    }\n\n    this.inlineStack.push(expr);\n    return expr;\n  },\n\n  pushStackLiteral: function(item) {\n    this.push(new Literal(item));\n  },\n\n  pushSource: function(source) {\n    if (this.pendingContent) {\n      this.source.push(\n        this.appendToBuffer(\n          this.source.quotedString(this.pendingContent),\n          this.pendingLocation\n        )\n      );\n      this.pendingContent = undefined;\n    }\n\n    if (source) {\n      this.source.push(source);\n    }\n  },\n\n  replaceStack: function(callback) {\n    let prefix = ['('],\n      stack,\n      createdStack,\n      usedLiteral;\n\n    /* istanbul ignore next */\n    if (!this.isInline()) {\n      throw new Exception('replaceStack on non-inline');\n    }\n\n    // We want to merge the inline statement into the replacement statement via ','\n    let top = this.popStack(true);\n\n    if (top instanceof Literal) {\n      // Literals do not need to be inlined\n      stack = [top.value];\n      prefix = ['(', stack];\n      usedLiteral = true;\n    } else {\n      // Get or create the current stack name for use by the inline\n      createdStack = true;\n      let name = this.incrStack();\n\n      prefix = ['((', this.push(name), ' = ', top, ')'];\n      stack = this.topStack();\n    }\n\n    let item = callback.call(this, stack);\n\n    if (!usedLiteral) {\n      this.popStack();\n    }\n    if (createdStack) {\n      this.stackSlot--;\n    }\n    this.push(prefix.concat(item, ')'));\n  },\n\n  incrStack: function() {\n    this.stackSlot++;\n    if (this.stackSlot > this.stackVars.length) {\n      this.stackVars.push('stack' + this.stackSlot);\n    }\n    return this.topStackName();\n  },\n  topStackName: function() {\n    return 'stack' + this.stackSlot;\n  },\n  flushInline: function() {\n    let inlineStack = this.inlineStack;\n    this.inlineStack = [];\n    for (let i = 0, len = inlineStack.length; i < len; i++) {\n      let entry = inlineStack[i];\n      /* istanbul ignore if */\n      if (entry instanceof Literal) {\n        this.compileStack.push(entry);\n      } else {\n        let stack = this.incrStack();\n        this.pushSource([stack, ' = ', entry, ';']);\n        this.compileStack.push(stack);\n      }\n    }\n  },\n  isInline: function() {\n    return this.inlineStack.length;\n  },\n\n  popStack: function(wrapped) {\n    let inline = this.isInline(),\n      item = (inline ? this.inlineStack : this.compileStack).pop();\n\n    if (!wrapped && item instanceof Literal) {\n      return item.value;\n    } else {\n      if (!inline) {\n        /* istanbul ignore next */\n        if (!this.stackSlot) {\n          throw new Exception('Invalid stack pop');\n        }\n        this.stackSlot--;\n      }\n      return item;\n    }\n  },\n\n  topStack: function() {\n    let stack = this.isInline() ? this.inlineStack : this.compileStack,\n      item = stack[stack.length - 1];\n\n    /* istanbul ignore if */\n    if (item instanceof Literal) {\n      return item.value;\n    } else {\n      return item;\n    }\n  },\n\n  contextName: function(context) {\n    if (this.useDepths && context) {\n      return 'depths[' + context + ']';\n    } else {\n      return 'depth' + context;\n    }\n  },\n\n  quotedString: function(str) {\n    return this.source.quotedString(str);\n  },\n\n  objectLiteral: function(obj) {\n    return this.source.objectLiteral(obj);\n  },\n\n  aliasable: function(name) {\n    let ret = this.aliases[name];\n    if (ret) {\n      ret.referenceCount++;\n      return ret;\n    }\n\n    ret = this.aliases[name] = this.source.wrap(name);\n    ret.aliasable = true;\n    ret.referenceCount = 1;\n\n    return ret;\n  },\n\n  setupHelper: function(paramSize, name, blockHelper) {\n    let params = [],\n      paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);\n    let foundHelper = this.nameLookup('helpers', name, 'helper'),\n      callContext = this.aliasable(\n        `${this.contextName(0)} != null ? ${this.contextName(\n          0\n        )} : (container.nullContext || {})`\n      );\n\n    return {\n      params: params,\n      paramsInit: paramsInit,\n      name: foundHelper,\n      callParams: [callContext].concat(params)\n    };\n  },\n\n  setupParams: function(helper, paramSize, params) {\n    let options = {},\n      contexts = [],\n      types = [],\n      ids = [],\n      objectArgs = !params,\n      param;\n\n    if (objectArgs) {\n      params = [];\n    }\n\n    options.name = this.quotedString(helper);\n    options.hash = this.popStack();\n\n    if (this.trackIds) {\n      options.hashIds = this.popStack();\n    }\n    if (this.stringParams) {\n      options.hashTypes = this.popStack();\n      options.hashContexts = this.popStack();\n    }\n\n    let inverse = this.popStack(),\n      program = this.popStack();\n\n    // Avoid setting fn and inverse if neither are set. This allows\n    // helpers to do a check for `if (options.fn)`\n    if (program || inverse) {\n      options.fn = program || 'container.noop';\n      options.inverse = inverse || 'container.noop';\n    }\n\n    // The parameters go on to the stack in order (making sure that they are evaluated in order)\n    // so we need to pop them off the stack in reverse order\n    let i = paramSize;\n    while (i--) {\n      param = this.popStack();\n      params[i] = param;\n\n      if (this.trackIds) {\n        ids[i] = this.popStack();\n      }\n      if (this.stringParams) {\n        types[i] = this.popStack();\n        contexts[i] = this.popStack();\n      }\n    }\n\n    if (objectArgs) {\n      options.args = this.source.generateArray(params);\n    }\n\n    if (this.trackIds) {\n      options.ids = this.source.generateArray(ids);\n    }\n    if (this.stringParams) {\n      options.types = this.source.generateArray(types);\n      options.contexts = this.source.generateArray(contexts);\n    }\n\n    if (this.options.data) {\n      options.data = 'data';\n    }\n    if (this.useBlockParams) {\n      options.blockParams = 'blockParams';\n    }\n    return options;\n  },\n\n  setupHelperArgs: function(helper, paramSize, params, useRegister) {\n    let options = this.setupParams(helper, paramSize, params);\n    options.loc = JSON.stringify(this.source.currentLocation);\n    options = this.objectLiteral(options);\n    if (useRegister) {\n      this.useRegister('options');\n      params.push('options');\n      return ['options=', options];\n    } else if (params) {\n      params.push(options);\n      return '';\n    } else {\n      return options;\n    }\n  }\n};\n\n(function() {\n  const reservedWords = (\n    'break else new var' +\n    ' case finally return void' +\n    ' catch for switch while' +\n    ' continue function this with' +\n    ' default if throw' +\n    ' delete in try' +\n    ' do instanceof typeof' +\n    ' abstract enum int short' +\n    ' boolean export interface static' +\n    ' byte extends long super' +\n    ' char final native synchronized' +\n    ' class float package throws' +\n    ' const goto private transient' +\n    ' debugger implements protected volatile' +\n    ' double import public let yield await' +\n    ' null true false'\n  ).split(' ');\n\n  const compilerWords = (JavaScriptCompiler.RESERVED_WORDS = {});\n\n  for (let i = 0, l = reservedWords.length; i < l; i++) {\n    compilerWords[reservedWords[i]] = true;\n  }\n})();\n\n/**\n * @deprecated May be removed in the next major version\n */\nJavaScriptCompiler.isValidJavaScriptVariableName = function(name) {\n  return (\n    !JavaScriptCompiler.RESERVED_WORDS[name] &&\n    /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name)\n  );\n};\n\nfunction strictLookup(requireTerminal, compiler, parts, type) {\n  let stack = compiler.popStack(),\n    i = 0,\n    len = parts.length;\n  if (requireTerminal) {\n    len--;\n  }\n\n  for (; i < len; i++) {\n    stack = compiler.nameLookup(stack, parts[i], type);\n  }\n\n  if (requireTerminal) {\n    return [\n      compiler.aliasable('container.strict'),\n      '(',\n      stack,\n      ', ',\n      compiler.quotedString(parts[i]),\n      ', ',\n      JSON.stringify(compiler.source.currentLocation),\n      ' )'\n    ];\n  } else {\n    return stack;\n  }\n}\n\nexport default JavaScriptCompiler;\n"]},"metadata":{},"sourceType":"script"}