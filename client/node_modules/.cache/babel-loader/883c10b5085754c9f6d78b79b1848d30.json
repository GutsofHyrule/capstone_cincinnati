{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createEachStatement = exports.createConditionStatement = exports.resolveBlockStatement = void 0;\n\nvar Babel = require(\"@babel/types\");\n\nvar expressions_1 = require(\"./expressions\");\n\nvar elements_1 = require(\"./elements\");\n\nvar constants_1 = require(\"./constants\");\n/**\n * Resolves block type\n */\n\n\nexports.resolveBlockStatement = function (blockStatement) {\n  switch (blockStatement.path.original) {\n    case 'if':\n      {\n        return exports.createConditionStatement(blockStatement, false);\n      }\n\n    case 'unless':\n      {\n        return exports.createConditionStatement(blockStatement, true);\n      }\n\n    case 'each':\n      {\n        return exports.createEachStatement(blockStatement);\n      }\n\n    default:\n      {\n        throw new Error(\"Unexpected \" + blockStatement.path.original + \" statement\");\n      }\n  }\n};\n/**\n * Creates condition statement\n */\n\n\nexports.createConditionStatement = function (blockStatement, invertCondition) {\n  var program = blockStatement.program,\n      inverse = blockStatement.inverse;\n  var boolCondSubject = Babel.callExpression(Babel.identifier('Boolean'), [expressions_1.resolveExpression(blockStatement.params[0])]);\n\n  if (invertCondition) {\n    boolCondSubject = Babel.unaryExpression('!', boolCondSubject);\n  }\n\n  if (inverse == null) {\n    // Logical expression\n    // {Boolean(variable) && <div />}\n    return Babel.logicalExpression('&&', boolCondSubject, expressions_1.createRootChildren(program.body));\n  } else {\n    // Ternary expression\n    // {Boolean(variable) ? <div /> : <span />}\n    return Babel.conditionalExpression(boolCondSubject, expressions_1.createRootChildren(program.body), expressions_1.createRootChildren(inverse.body));\n  }\n};\n/**\n * Creates each block statement\n */\n\n\nexports.createEachStatement = function (blockStatement) {\n  var pathExpression = blockStatement.params[0];\n  var iterator = expressions_1.appendToPath(expressions_1.createPath(pathExpression), Babel.identifier('map'));\n  var mapCallbackChildren = expressions_1.createRootChildren(blockStatement.program.body); // If top-level child element is JS expression, wrap into fragment to add\n  // the \"key\" attribute.\n\n  var wrappedCallbackChildren = !Babel.isJSXElement(mapCallbackChildren) ? elements_1.createFragment([Babel.jsxExpressionContainer(mapCallbackChildren)]) : mapCallbackChildren; // Adding the \"key\" attribute to child element\n\n  wrappedCallbackChildren.openingElement.attributes.push(Babel.jsxAttribute(Babel.jsxIdentifier('key'), Babel.jsxExpressionContainer(Babel.identifier(constants_1.DEFAULT_KEY_NAME))));\n  var mapCallback = Babel.arrowFunctionExpression([Babel.identifier(constants_1.DEFAULT_NAMESPACE_NAME), Babel.identifier(constants_1.DEFAULT_KEY_NAME)], wrappedCallbackChildren);\n  return Babel.callExpression(iterator, [mapCallback]);\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","createEachStatement","createConditionStatement","resolveBlockStatement","Babel","require","expressions_1","elements_1","constants_1","blockStatement","path","original","Error","invertCondition","program","inverse","boolCondSubject","callExpression","identifier","resolveExpression","params","unaryExpression","logicalExpression","createRootChildren","body","conditionalExpression","pathExpression","iterator","appendToPath","createPath","mapCallbackChildren","wrappedCallbackChildren","isJSXElement","createFragment","jsxExpressionContainer","openingElement","attributes","push","jsxAttribute","jsxIdentifier","DEFAULT_KEY_NAME","mapCallback","arrowFunctionExpression","DEFAULT_NAMESPACE_NAME"],"sources":["C:/Users/KA-001/HT Coding projects/capstone_cincinnati/node_modules/handlebars-to-jsx/dist/blockStatements.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createEachStatement = exports.createConditionStatement = exports.resolveBlockStatement = void 0;\nvar Babel = require(\"@babel/types\");\nvar expressions_1 = require(\"./expressions\");\nvar elements_1 = require(\"./elements\");\nvar constants_1 = require(\"./constants\");\n/**\n * Resolves block type\n */\nexports.resolveBlockStatement = function (blockStatement) {\n    switch (blockStatement.path.original) {\n        case 'if': {\n            return exports.createConditionStatement(blockStatement, false);\n        }\n        case 'unless': {\n            return exports.createConditionStatement(blockStatement, true);\n        }\n        case 'each': {\n            return exports.createEachStatement(blockStatement);\n        }\n        default: {\n            throw new Error(\"Unexpected \" + blockStatement.path.original + \" statement\");\n        }\n    }\n};\n/**\n * Creates condition statement\n */\nexports.createConditionStatement = function (blockStatement, invertCondition) {\n    var program = blockStatement.program, inverse = blockStatement.inverse;\n    var boolCondSubject = Babel.callExpression(Babel.identifier('Boolean'), [expressions_1.resolveExpression(blockStatement.params[0])]);\n    if (invertCondition) {\n        boolCondSubject = Babel.unaryExpression('!', boolCondSubject);\n    }\n    if (inverse == null) {\n        // Logical expression\n        // {Boolean(variable) && <div />}\n        return Babel.logicalExpression('&&', boolCondSubject, expressions_1.createRootChildren(program.body));\n    }\n    else {\n        // Ternary expression\n        // {Boolean(variable) ? <div /> : <span />}\n        return Babel.conditionalExpression(boolCondSubject, expressions_1.createRootChildren(program.body), expressions_1.createRootChildren(inverse.body));\n    }\n};\n/**\n * Creates each block statement\n */\nexports.createEachStatement = function (blockStatement) {\n    var pathExpression = blockStatement.params[0];\n    var iterator = expressions_1.appendToPath(expressions_1.createPath(pathExpression), Babel.identifier('map'));\n    var mapCallbackChildren = expressions_1.createRootChildren(blockStatement.program.body);\n    // If top-level child element is JS expression, wrap into fragment to add\n    // the \"key\" attribute.\n    var wrappedCallbackChildren = !Babel.isJSXElement(mapCallbackChildren)\n        ? elements_1.createFragment([Babel.jsxExpressionContainer(mapCallbackChildren)])\n        : mapCallbackChildren;\n    // Adding the \"key\" attribute to child element\n    wrappedCallbackChildren.openingElement.attributes.push(Babel.jsxAttribute(Babel.jsxIdentifier('key'), Babel.jsxExpressionContainer(Babel.identifier(constants_1.DEFAULT_KEY_NAME))));\n    var mapCallback = Babel.arrowFunctionExpression([Babel.identifier(constants_1.DEFAULT_NAMESPACE_NAME), Babel.identifier(constants_1.DEFAULT_KEY_NAME)], wrappedCallbackChildren);\n    return Babel.callExpression(iterator, [mapCallback]);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}