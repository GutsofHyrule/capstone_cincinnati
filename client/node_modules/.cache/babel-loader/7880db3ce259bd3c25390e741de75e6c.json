{"ast":null,"code":"'use strict';\n\nexports.__esModule = true; // istanbul ignore next\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar _exception = require('../exception');\n\nvar _exception2 = _interopRequireDefault(_exception);\n\nfunction Visitor() {\n  this.parents = [];\n}\n\nVisitor.prototype = {\n  constructor: Visitor,\n  mutating: false,\n  // Visits a given value. If mutating, will replace the value if necessary.\n  acceptKey: function acceptKey(node, name) {\n    var value = this.accept(node[name]);\n\n    if (this.mutating) {\n      // Hacky sanity check: This may have a few false positives for type for the helper\n      // methods but will generally do the right thing without a lot of overhead.\n      if (value && !Visitor.prototype[value.type]) {\n        throw new _exception2['default']('Unexpected node type \"' + value.type + '\" found when accepting ' + name + ' on ' + node.type);\n      }\n\n      node[name] = value;\n    }\n  },\n  // Performs an accept operation with added sanity check to ensure\n  // required keys are not removed.\n  acceptRequired: function acceptRequired(node, name) {\n    this.acceptKey(node, name);\n\n    if (!node[name]) {\n      throw new _exception2['default'](node.type + ' requires ' + name);\n    }\n  },\n  // Traverses a given array. If mutating, empty respnses will be removed\n  // for child elements.\n  acceptArray: function acceptArray(array) {\n    for (var i = 0, l = array.length; i < l; i++) {\n      this.acceptKey(array, i);\n\n      if (!array[i]) {\n        array.splice(i, 1);\n        i--;\n        l--;\n      }\n    }\n  },\n  accept: function accept(object) {\n    if (!object) {\n      return;\n    }\n    /* istanbul ignore next: Sanity code */\n\n\n    if (!this[object.type]) {\n      throw new _exception2['default']('Unknown type: ' + object.type, object);\n    }\n\n    if (this.current) {\n      this.parents.unshift(this.current);\n    }\n\n    this.current = object;\n    var ret = this[object.type](object);\n    this.current = this.parents.shift();\n\n    if (!this.mutating || ret) {\n      return ret;\n    } else if (ret !== false) {\n      return object;\n    }\n  },\n  Program: function Program(program) {\n    this.acceptArray(program.body);\n  },\n  MustacheStatement: visitSubExpression,\n  Decorator: visitSubExpression,\n  BlockStatement: visitBlock,\n  DecoratorBlock: visitBlock,\n  PartialStatement: visitPartial,\n  PartialBlockStatement: function PartialBlockStatement(partial) {\n    visitPartial.call(this, partial);\n    this.acceptKey(partial, 'program');\n  },\n  ContentStatement: function ContentStatement()\n  /* content */\n  {},\n  CommentStatement: function CommentStatement()\n  /* comment */\n  {},\n  SubExpression: visitSubExpression,\n  PathExpression: function PathExpression()\n  /* path */\n  {},\n  StringLiteral: function StringLiteral()\n  /* string */\n  {},\n  NumberLiteral: function NumberLiteral()\n  /* number */\n  {},\n  BooleanLiteral: function BooleanLiteral()\n  /* bool */\n  {},\n  UndefinedLiteral: function UndefinedLiteral()\n  /* literal */\n  {},\n  NullLiteral: function NullLiteral()\n  /* literal */\n  {},\n  Hash: function Hash(hash) {\n    this.acceptArray(hash.pairs);\n  },\n  HashPair: function HashPair(pair) {\n    this.acceptRequired(pair, 'value');\n  }\n};\n\nfunction visitSubExpression(mustache) {\n  this.acceptRequired(mustache, 'path');\n  this.acceptArray(mustache.params);\n  this.acceptKey(mustache, 'hash');\n}\n\nfunction visitBlock(block) {\n  visitSubExpression.call(this, block);\n  this.acceptKey(block, 'program');\n  this.acceptKey(block, 'inverse');\n}\n\nfunction visitPartial(partial) {\n  this.acceptRequired(partial, 'name');\n  this.acceptArray(partial.params);\n  this.acceptKey(partial, 'hash');\n}\n\nexports['default'] = Visitor;\nmodule.exports = exports['default'];","map":{"version":3,"mappings":"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","names":["Visitor","parents","prototype","constructor","mutating","acceptKey","node","name","value","accept","type","acceptRequired","acceptArray","array","i","l","length","splice","object","current","unshift","ret","shift","Program","program","body","MustacheStatement","visitSubExpression","Decorator","BlockStatement","visitBlock","DecoratorBlock","PartialStatement","visitPartial","PartialBlockStatement","partial","call","ContentStatement","CommentStatement","SubExpression","PathExpression","StringLiteral","NumberLiteral","BooleanLiteral","UndefinedLiteral","NullLiteral","Hash","hash","pairs","HashPair","pair","mustache","params","block"],"sources":["../../../../lib/handlebars/compiler/visitor.js"],"sourcesContent":["import Exception from '../exception';\n\nfunction Visitor() {\n  this.parents = [];\n}\n\nVisitor.prototype = {\n  constructor: Visitor,\n  mutating: false,\n\n  // Visits a given value. If mutating, will replace the value if necessary.\n  acceptKey: function(node, name) {\n    let value = this.accept(node[name]);\n    if (this.mutating) {\n      // Hacky sanity check: This may have a few false positives for type for the helper\n      // methods but will generally do the right thing without a lot of overhead.\n      if (value && !Visitor.prototype[value.type]) {\n        throw new Exception(\n          'Unexpected node type \"' +\n            value.type +\n            '\" found when accepting ' +\n            name +\n            ' on ' +\n            node.type\n        );\n      }\n      node[name] = value;\n    }\n  },\n\n  // Performs an accept operation with added sanity check to ensure\n  // required keys are not removed.\n  acceptRequired: function(node, name) {\n    this.acceptKey(node, name);\n\n    if (!node[name]) {\n      throw new Exception(node.type + ' requires ' + name);\n    }\n  },\n\n  // Traverses a given array. If mutating, empty respnses will be removed\n  // for child elements.\n  acceptArray: function(array) {\n    for (let i = 0, l = array.length; i < l; i++) {\n      this.acceptKey(array, i);\n\n      if (!array[i]) {\n        array.splice(i, 1);\n        i--;\n        l--;\n      }\n    }\n  },\n\n  accept: function(object) {\n    if (!object) {\n      return;\n    }\n\n    /* istanbul ignore next: Sanity code */\n    if (!this[object.type]) {\n      throw new Exception('Unknown type: ' + object.type, object);\n    }\n\n    if (this.current) {\n      this.parents.unshift(this.current);\n    }\n    this.current = object;\n\n    let ret = this[object.type](object);\n\n    this.current = this.parents.shift();\n\n    if (!this.mutating || ret) {\n      return ret;\n    } else if (ret !== false) {\n      return object;\n    }\n  },\n\n  Program: function(program) {\n    this.acceptArray(program.body);\n  },\n\n  MustacheStatement: visitSubExpression,\n  Decorator: visitSubExpression,\n\n  BlockStatement: visitBlock,\n  DecoratorBlock: visitBlock,\n\n  PartialStatement: visitPartial,\n  PartialBlockStatement: function(partial) {\n    visitPartial.call(this, partial);\n\n    this.acceptKey(partial, 'program');\n  },\n\n  ContentStatement: function(/* content */) {},\n  CommentStatement: function(/* comment */) {},\n\n  SubExpression: visitSubExpression,\n\n  PathExpression: function(/* path */) {},\n\n  StringLiteral: function(/* string */) {},\n  NumberLiteral: function(/* number */) {},\n  BooleanLiteral: function(/* bool */) {},\n  UndefinedLiteral: function(/* literal */) {},\n  NullLiteral: function(/* literal */) {},\n\n  Hash: function(hash) {\n    this.acceptArray(hash.pairs);\n  },\n  HashPair: function(pair) {\n    this.acceptRequired(pair, 'value');\n  }\n};\n\nfunction visitSubExpression(mustache) {\n  this.acceptRequired(mustache, 'path');\n  this.acceptArray(mustache.params);\n  this.acceptKey(mustache, 'hash');\n}\nfunction visitBlock(block) {\n  visitSubExpression.call(this, block);\n\n  this.acceptKey(block, 'program');\n  this.acceptKey(block, 'inverse');\n}\nfunction visitPartial(partial) {\n  this.acceptRequired(partial, 'name');\n  this.acceptArray(partial.params);\n  this.acceptKey(partial, 'hash');\n}\n\nexport default Visitor;\n"]},"metadata":{},"sourceType":"script"}