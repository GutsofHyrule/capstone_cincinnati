{"ast":null,"code":"import SyntaxError from './errors/syntax-error'; // Regex to validate the identifier for block parameters.\n// Based on the ID validation regex in Handlebars.\n\nlet ID_INVERSE_PATTERN = /[!\"#%-,\\.\\/;->@\\[-\\^`\\{-~]/; // Checks the element's attributes to see if it uses block params.\n// If it does, registers the block params with the program and\n// removes the corresponding attributes from the element.\n\nexport function parseElementBlockParams(element) {\n  let params = parseBlockParams(element);\n  if (params) element.blockParams = params;\n}\n\nfunction parseBlockParams(element) {\n  let l = element.attributes.length;\n  let attrNames = [];\n\n  for (let i = 0; i < l; i++) {\n    attrNames.push(element.attributes[i].name);\n  }\n\n  let asIndex = attrNames.indexOf('as');\n\n  if (asIndex !== -1 && l > asIndex && attrNames[asIndex + 1].charAt(0) === '|') {\n    // Some basic validation, since we're doing the parsing ourselves\n    let paramsString = attrNames.slice(asIndex).join(' ');\n\n    if (paramsString.charAt(paramsString.length - 1) !== '|' || paramsString.match(/\\|/g).length !== 2) {\n      throw new SyntaxError(\"Invalid block parameters syntax: '\" + paramsString + \"'\", element.loc);\n    }\n\n    let params = [];\n\n    for (let i = asIndex + 1; i < l; i++) {\n      let param = attrNames[i].replace(/\\|/g, '');\n\n      if (param !== '') {\n        if (ID_INVERSE_PATTERN.test(param)) {\n          throw new SyntaxError(\"Invalid identifier for block parameters: '\" + param + \"' in '\" + paramsString + \"'\", element.loc);\n        }\n\n        params.push(param);\n      }\n    }\n\n    if (params.length === 0) {\n      throw new SyntaxError(\"Cannot use zero block parameters: '\" + paramsString + \"'\", element.loc);\n    }\n\n    element.attributes = element.attributes.slice(0, asIndex);\n    return params;\n  }\n\n  return null;\n}\n\nexport function childrenFor(node) {\n  switch (node.type) {\n    case 'Program':\n      return node.body;\n\n    case 'ElementNode':\n      return node.children;\n  }\n}\nexport function appendChild(parent, node) {\n  childrenFor(parent).push(node);\n}\nexport function isLiteral(path) {\n  return path.type === 'StringLiteral' || path.type === 'BooleanLiteral' || path.type === 'NumberLiteral' || path.type === 'NullLiteral' || path.type === 'UndefinedLiteral';\n}\nexport function printLiteral(literal) {\n  if (literal.type === 'UndefinedLiteral') {\n    return 'undefined';\n  } else {\n    return JSON.stringify(literal.value);\n  }\n}","map":{"version":3,"mappings":"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","names":["SyntaxError","ID_INVERSE_PATTERN","parseElementBlockParams","element","params","parseBlockParams","blockParams","l","attributes","length","attrNames","i","push","name","asIndex","indexOf","charAt","paramsString","slice","join","match","loc","param","replace","test","childrenFor","node","type","body","children","appendChild","parent","isLiteral","path","printLiteral","literal","JSON","stringify","value"],"sourceRoot":"","sources":["../../../../packages/@glimmer/syntax/lib/utils.ts"],"sourcesContent":["import * as AST from './types/nodes';\nimport { Option } from '@glimmer/interfaces';\nimport SyntaxError from './errors/syntax-error';\n\n// Regex to validate the identifier for block parameters.\n// Based on the ID validation regex in Handlebars.\n\nlet ID_INVERSE_PATTERN = /[!\"#%-,\\.\\/;->@\\[-\\^`\\{-~]/;\n\n// Checks the element's attributes to see if it uses block params.\n// If it does, registers the block params with the program and\n// removes the corresponding attributes from the element.\n\nexport function parseElementBlockParams(element: AST.ElementNode) {\n  let params = parseBlockParams(element);\n  if (params) element.blockParams = params;\n}\n\nfunction parseBlockParams(element: AST.ElementNode): Option<string[]> {\n  let l = element.attributes.length;\n  let attrNames = [];\n\n  for (let i = 0; i < l; i++) {\n    attrNames.push(element.attributes[i].name);\n  }\n\n  let asIndex = attrNames.indexOf('as');\n\n  if (asIndex !== -1 && l > asIndex && attrNames[asIndex + 1].charAt(0) === '|') {\n    // Some basic validation, since we're doing the parsing ourselves\n    let paramsString = attrNames.slice(asIndex).join(' ');\n    if (\n      paramsString.charAt(paramsString.length - 1) !== '|' ||\n      paramsString.match(/\\|/g)!.length !== 2\n    ) {\n      throw new SyntaxError(\"Invalid block parameters syntax: '\" + paramsString + \"'\", element.loc);\n    }\n\n    let params = [];\n    for (let i = asIndex + 1; i < l; i++) {\n      let param = attrNames[i].replace(/\\|/g, '');\n      if (param !== '') {\n        if (ID_INVERSE_PATTERN.test(param)) {\n          throw new SyntaxError(\n            \"Invalid identifier for block parameters: '\" + param + \"' in '\" + paramsString + \"'\",\n            element.loc\n          );\n        }\n        params.push(param);\n      }\n    }\n\n    if (params.length === 0) {\n      throw new SyntaxError(\n        \"Cannot use zero block parameters: '\" + paramsString + \"'\",\n        element.loc\n      );\n    }\n\n    element.attributes = element.attributes.slice(0, asIndex);\n    return params;\n  }\n\n  return null;\n}\n\nexport function childrenFor(node: AST.Program | AST.ElementNode): AST.Statement[] {\n  switch (node.type) {\n    case 'Program':\n      return node.body;\n    case 'ElementNode':\n      return node.children;\n  }\n}\n\nexport function appendChild(parent: AST.Program | AST.ElementNode, node: AST.Statement) {\n  childrenFor(parent).push(node);\n}\n\nexport function isLiteral(path: AST.PathExpression | AST.Literal): path is AST.Literal {\n  return (\n    path.type === 'StringLiteral' ||\n    path.type === 'BooleanLiteral' ||\n    path.type === 'NumberLiteral' ||\n    path.type === 'NullLiteral' ||\n    path.type === 'UndefinedLiteral'\n  );\n}\n\nexport function printLiteral(literal: AST.Literal): string {\n  if (literal.type === 'UndefinedLiteral') {\n    return 'undefined';\n  } else {\n    return JSON.stringify(literal.value);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}