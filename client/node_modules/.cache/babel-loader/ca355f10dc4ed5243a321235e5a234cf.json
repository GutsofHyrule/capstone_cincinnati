{"ast":null,"code":"import { EventedTokenizer, EntityParser, HTML5NamedCharRefs as namedCharRefs } from 'simple-html-tokenizer';\nimport { assert } from '@glimmer/util';\nconst entityParser = new EntityParser(namedCharRefs);\nexport class Parser {\n  constructor(source) {\n    this.elementStack = [];\n    this.currentAttribute = null;\n    this.currentNode = null;\n    this.tokenizer = new EventedTokenizer(this, entityParser);\n    this.source = source.split(/(?:\\r\\n?|\\n)/g);\n  }\n\n  get currentAttr() {\n    return this.currentAttribute;\n  }\n\n  get currentTag() {\n    let node = this.currentNode;\n    false && assert(node && (node.type === 'StartTag' || node.type === 'EndTag'), 'expected tag');\n    return node;\n  }\n\n  get currentStartTag() {\n    let node = this.currentNode;\n    false && assert(node && node.type === 'StartTag', 'expected start tag');\n    return node;\n  }\n\n  get currentEndTag() {\n    let node = this.currentNode;\n    false && assert(node && node.type === 'EndTag', 'expected end tag');\n    return node;\n  }\n\n  get currentComment() {\n    let node = this.currentNode;\n    false && assert(node && node.type === 'CommentStatement', 'expected a comment');\n    return node;\n  }\n\n  get currentData() {\n    let node = this.currentNode;\n    false && assert(node && node.type === 'TextNode', 'expected a text node');\n    return node;\n  }\n\n  acceptNode(node) {\n    return this[node.type](node);\n  }\n\n  currentElement() {\n    return this.elementStack[this.elementStack.length - 1];\n  }\n\n  sourceForNode(node, endNode) {\n    let firstLine = node.loc.start.line - 1;\n    let currentLine = firstLine - 1;\n    let firstColumn = node.loc.start.column;\n    let string = [];\n    let line;\n    let lastLine;\n    let lastColumn;\n\n    if (endNode) {\n      lastLine = endNode.loc.end.line - 1;\n      lastColumn = endNode.loc.end.column;\n    } else {\n      lastLine = node.loc.end.line - 1;\n      lastColumn = node.loc.end.column;\n    }\n\n    while (currentLine < lastLine) {\n      currentLine++;\n      line = this.source[currentLine];\n\n      if (currentLine === firstLine) {\n        if (firstLine === lastLine) {\n          string.push(line.slice(firstColumn, lastColumn));\n        } else {\n          string.push(line.slice(firstColumn));\n        }\n      } else if (currentLine === lastLine) {\n        string.push(line.slice(0, lastColumn));\n      } else {\n        string.push(line);\n      }\n    }\n\n    return string.join('\\n');\n  }\n\n}","map":{"version":3,"mappings":"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","names":["EventedTokenizer","EntityParser","HTML5NamedCharRefs","namedCharRefs","assert","entityParser","Parser","constructor","source","elementStack","currentAttribute","currentNode","tokenizer","split","currentAttr","currentTag","node","type","currentStartTag","currentEndTag","currentComment","currentData","acceptNode","currentElement","length","sourceForNode","endNode","firstLine","loc","start","line","currentLine","firstColumn","column","string","lastLine","lastColumn","end","push","slice","join"],"sourceRoot":"","sources":["../../../../packages/@glimmer/syntax/lib/parser.ts"],"sourcesContent":["import {\n  EventedTokenizer,\n  EntityParser,\n  HTML5NamedCharRefs as namedCharRefs,\n} from 'simple-html-tokenizer';\nimport { Program } from './types/nodes';\nimport * as AST from './types/nodes';\nimport * as HandlebarsAST from './types/handlebars-ast';\nimport { Option } from '@glimmer/interfaces';\nimport { assert, expect } from '@glimmer/util';\n\nconst entityParser = new EntityParser(namedCharRefs);\n\nexport type Element = AST.Program | AST.ElementNode;\n\nexport interface Tag<T extends 'StartTag' | 'EndTag'> {\n  type: T;\n  name: string;\n  attributes: any[];\n  modifiers: any[];\n  comments: any[];\n  selfClosing: boolean;\n  loc: AST.SourceLocation;\n}\n\nexport interface Attribute {\n  name: string;\n  parts: (AST.MustacheStatement | AST.TextNode)[];\n  isQuoted: boolean;\n  isDynamic: boolean;\n  start: AST.Position;\n  valueStartLine: number;\n  valueStartColumn: number;\n}\n\nexport abstract class Parser {\n  protected elementStack: Element[] = [];\n  private source: string[];\n  public currentAttribute: Option<Attribute> = null;\n  public currentNode: Option<\n    AST.CommentStatement | AST.TextNode | Tag<'StartTag' | 'EndTag'>\n  > = null;\n  public tokenizer = new EventedTokenizer(this, entityParser);\n\n  constructor(source: string) {\n    this.source = source.split(/(?:\\r\\n?|\\n)/g);\n  }\n\n  abstract reset(): void;\n  abstract finishData(): void;\n  abstract tagOpen(): void;\n  abstract beginData(): void;\n  abstract appendToData(char: string): void;\n  abstract beginStartTag(): void;\n  abstract appendToTagName(char: string): void;\n  abstract beginAttribute(): void;\n  abstract appendToAttributeName(char: string): void;\n  abstract beginAttributeValue(quoted: boolean): void;\n  abstract appendToAttributeValue(char: string): void;\n  abstract finishAttributeValue(): void;\n  abstract markTagAsSelfClosing(): void;\n  abstract beginEndTag(): void;\n  abstract finishTag(): void;\n  abstract beginComment(): void;\n  abstract appendToCommentData(char: string): void;\n  abstract finishComment(): void;\n  abstract reportSyntaxError(error: string): void;\n\n  get currentAttr(): Attribute {\n    return expect(this.currentAttribute, 'expected attribute');\n  }\n\n  get currentTag(): Tag<'StartTag' | 'EndTag'> {\n    let node = this.currentNode;\n    assert(node && (node.type === 'StartTag' || node.type === 'EndTag'), 'expected tag');\n    return node as Tag<'StartTag' | 'EndTag'>;\n  }\n\n  get currentStartTag(): Tag<'StartTag'> {\n    let node = this.currentNode;\n    assert(node && node.type === 'StartTag', 'expected start tag');\n    return node as Tag<'StartTag'>;\n  }\n\n  get currentEndTag(): Tag<'EndTag'> {\n    let node = this.currentNode;\n    assert(node && node.type === 'EndTag', 'expected end tag');\n    return node as Tag<'EndTag'>;\n  }\n\n  get currentComment(): AST.CommentStatement {\n    let node = this.currentNode;\n    assert(node && node.type === 'CommentStatement', 'expected a comment');\n    return node as AST.CommentStatement;\n  }\n\n  get currentData(): AST.TextNode {\n    let node = this.currentNode;\n    assert(node && node.type === 'TextNode', 'expected a text node');\n    return node as AST.TextNode;\n  }\n\n  acceptNode(node: HandlebarsAST.Program): Program;\n  acceptNode<U extends AST.Node>(node: HandlebarsAST.Node): U;\n  acceptNode(node: HandlebarsAST.Node): any {\n    return this[node.type](node);\n  }\n\n  currentElement(): Element {\n    return this.elementStack[this.elementStack.length - 1];\n  }\n\n  sourceForNode(node: HandlebarsAST.Node, endNode?: { loc: HandlebarsAST.SourceLocation }): string {\n    let firstLine = node.loc.start.line - 1;\n    let currentLine = firstLine - 1;\n    let firstColumn = node.loc.start.column;\n    let string = [];\n    let line;\n\n    let lastLine: number;\n    let lastColumn: number;\n\n    if (endNode) {\n      lastLine = endNode.loc.end.line - 1;\n      lastColumn = endNode.loc.end.column;\n    } else {\n      lastLine = node.loc.end.line - 1;\n      lastColumn = node.loc.end.column;\n    }\n\n    while (currentLine < lastLine) {\n      currentLine++;\n      line = this.source[currentLine];\n\n      if (currentLine === firstLine) {\n        if (firstLine === lastLine) {\n          string.push(line.slice(firstColumn, lastColumn));\n        } else {\n          string.push(line.slice(firstColumn));\n        }\n      } else if (currentLine === lastLine) {\n        string.push(line.slice(0, lastColumn));\n      } else {\n        string.push(line);\n      }\n    }\n\n    return string.join('\\n');\n  }\n}\n"]},"metadata":{},"sourceType":"module"}