{"ast":null,"code":"/* eslint-disable new-cap */\n'use strict';\n\nexports.__esModule = true;\nexports.Compiler = Compiler;\nexports.precompile = precompile;\nexports.compile = compile; // istanbul ignore next\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar _exception = require('../exception');\n\nvar _exception2 = _interopRequireDefault(_exception);\n\nvar _utils = require('../utils');\n\nvar _ast = require('./ast');\n\nvar _ast2 = _interopRequireDefault(_ast);\n\nvar slice = [].slice;\n\nfunction Compiler() {} // the foundHelper register will disambiguate helper lookup from finding a\n// function in a context. This is necessary for mustache compatibility, which\n// requires that context functions in blocks are evaluated by blockHelperMissing,\n// and then proceed as if the resulting value was provided to blockHelperMissing.\n\n\nCompiler.prototype = {\n  compiler: Compiler,\n  equals: function equals(other) {\n    var len = this.opcodes.length;\n\n    if (other.opcodes.length !== len) {\n      return false;\n    }\n\n    for (var i = 0; i < len; i++) {\n      var opcode = this.opcodes[i],\n          otherOpcode = other.opcodes[i];\n\n      if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {\n        return false;\n      }\n    } // We know that length is the same between the two arrays because they are directly tied\n    // to the opcode behavior above.\n\n\n    len = this.children.length;\n\n    for (var i = 0; i < len; i++) {\n      if (!this.children[i].equals(other.children[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n  guid: 0,\n  compile: function compile(program, options) {\n    this.sourceNode = [];\n    this.opcodes = [];\n    this.children = [];\n    this.options = options;\n    this.stringParams = options.stringParams;\n    this.trackIds = options.trackIds;\n    options.blockParams = options.blockParams || [];\n    options.knownHelpers = _utils.extend(Object.create(null), {\n      helperMissing: true,\n      blockHelperMissing: true,\n      each: true,\n      'if': true,\n      unless: true,\n      'with': true,\n      log: true,\n      lookup: true\n    }, options.knownHelpers);\n    return this.accept(program);\n  },\n  compileProgram: function compileProgram(program) {\n    var childCompiler = new this.compiler(),\n        // eslint-disable-line new-cap\n    result = childCompiler.compile(program, this.options),\n        guid = this.guid++;\n    this.usePartial = this.usePartial || result.usePartial;\n    this.children[guid] = result;\n    this.useDepths = this.useDepths || result.useDepths;\n    return guid;\n  },\n  accept: function accept(node) {\n    /* istanbul ignore next: Sanity code */\n    if (!this[node.type]) {\n      throw new _exception2['default']('Unknown type: ' + node.type, node);\n    }\n\n    this.sourceNode.unshift(node);\n    var ret = this[node.type](node);\n    this.sourceNode.shift();\n    return ret;\n  },\n  Program: function Program(program) {\n    this.options.blockParams.unshift(program.blockParams);\n    var body = program.body,\n        bodyLength = body.length;\n\n    for (var i = 0; i < bodyLength; i++) {\n      this.accept(body[i]);\n    }\n\n    this.options.blockParams.shift();\n    this.isSimple = bodyLength === 1;\n    this.blockParams = program.blockParams ? program.blockParams.length : 0;\n    return this;\n  },\n  BlockStatement: function BlockStatement(block) {\n    transformLiteralToPath(block);\n    var program = block.program,\n        inverse = block.inverse;\n    program = program && this.compileProgram(program);\n    inverse = inverse && this.compileProgram(inverse);\n    var type = this.classifySexpr(block);\n\n    if (type === 'helper') {\n      this.helperSexpr(block, program, inverse);\n    } else if (type === 'simple') {\n      this.simpleSexpr(block); // now that the simple mustache is resolved, we need to\n      // evaluate it by executing `blockHelperMissing`\n\n      this.opcode('pushProgram', program);\n      this.opcode('pushProgram', inverse);\n      this.opcode('emptyHash');\n      this.opcode('blockValue', block.path.original);\n    } else {\n      this.ambiguousSexpr(block, program, inverse); // now that the simple mustache is resolved, we need to\n      // evaluate it by executing `blockHelperMissing`\n\n      this.opcode('pushProgram', program);\n      this.opcode('pushProgram', inverse);\n      this.opcode('emptyHash');\n      this.opcode('ambiguousBlockValue');\n    }\n\n    this.opcode('append');\n  },\n  DecoratorBlock: function DecoratorBlock(decorator) {\n    var program = decorator.program && this.compileProgram(decorator.program);\n    var params = this.setupFullMustacheParams(decorator, program, undefined),\n        path = decorator.path;\n    this.useDecorators = true;\n    this.opcode('registerDecorator', params.length, path.original);\n  },\n  PartialStatement: function PartialStatement(partial) {\n    this.usePartial = true;\n    var program = partial.program;\n\n    if (program) {\n      program = this.compileProgram(partial.program);\n    }\n\n    var params = partial.params;\n\n    if (params.length > 1) {\n      throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);\n    } else if (!params.length) {\n      if (this.options.explicitPartialContext) {\n        this.opcode('pushLiteral', 'undefined');\n      } else {\n        params.push({\n          type: 'PathExpression',\n          parts: [],\n          depth: 0\n        });\n      }\n    }\n\n    var partialName = partial.name.original,\n        isDynamic = partial.name.type === 'SubExpression';\n\n    if (isDynamic) {\n      this.accept(partial.name);\n    }\n\n    this.setupFullMustacheParams(partial, program, undefined, true);\n    var indent = partial.indent || '';\n\n    if (this.options.preventIndent && indent) {\n      this.opcode('appendContent', indent);\n      indent = '';\n    }\n\n    this.opcode('invokePartial', isDynamic, partialName, indent);\n    this.opcode('append');\n  },\n  PartialBlockStatement: function PartialBlockStatement(partialBlock) {\n    this.PartialStatement(partialBlock);\n  },\n  MustacheStatement: function MustacheStatement(mustache) {\n    this.SubExpression(mustache);\n\n    if (mustache.escaped && !this.options.noEscape) {\n      this.opcode('appendEscaped');\n    } else {\n      this.opcode('append');\n    }\n  },\n  Decorator: function Decorator(decorator) {\n    this.DecoratorBlock(decorator);\n  },\n  ContentStatement: function ContentStatement(content) {\n    if (content.value) {\n      this.opcode('appendContent', content.value);\n    }\n  },\n  CommentStatement: function CommentStatement() {},\n  SubExpression: function SubExpression(sexpr) {\n    transformLiteralToPath(sexpr);\n    var type = this.classifySexpr(sexpr);\n\n    if (type === 'simple') {\n      this.simpleSexpr(sexpr);\n    } else if (type === 'helper') {\n      this.helperSexpr(sexpr);\n    } else {\n      this.ambiguousSexpr(sexpr);\n    }\n  },\n  ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {\n    var path = sexpr.path,\n        name = path.parts[0],\n        isBlock = program != null || inverse != null;\n    this.opcode('getContext', path.depth);\n    this.opcode('pushProgram', program);\n    this.opcode('pushProgram', inverse);\n    path.strict = true;\n    this.accept(path);\n    this.opcode('invokeAmbiguous', name, isBlock);\n  },\n  simpleSexpr: function simpleSexpr(sexpr) {\n    var path = sexpr.path;\n    path.strict = true;\n    this.accept(path);\n    this.opcode('resolvePossibleLambda');\n  },\n  helperSexpr: function helperSexpr(sexpr, program, inverse) {\n    var params = this.setupFullMustacheParams(sexpr, program, inverse),\n        path = sexpr.path,\n        name = path.parts[0];\n\n    if (this.options.knownHelpers[name]) {\n      this.opcode('invokeKnownHelper', params.length, name);\n    } else if (this.options.knownHelpersOnly) {\n      throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);\n    } else {\n      path.strict = true;\n      path.falsy = true;\n      this.accept(path);\n      this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));\n    }\n  },\n  PathExpression: function PathExpression(path) {\n    this.addDepth(path.depth);\n    this.opcode('getContext', path.depth);\n\n    var name = path.parts[0],\n        scoped = _ast2['default'].helpers.scopedId(path),\n        blockParamId = !path.depth && !scoped && this.blockParamIndex(name);\n\n    if (blockParamId) {\n      this.opcode('lookupBlockParam', blockParamId, path.parts);\n    } else if (!name) {\n      // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`\n      this.opcode('pushContext');\n    } else if (path.data) {\n      this.options.data = true;\n      this.opcode('lookupData', path.depth, path.parts, path.strict);\n    } else {\n      this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);\n    }\n  },\n  StringLiteral: function StringLiteral(string) {\n    this.opcode('pushString', string.value);\n  },\n  NumberLiteral: function NumberLiteral(number) {\n    this.opcode('pushLiteral', number.value);\n  },\n  BooleanLiteral: function BooleanLiteral(bool) {\n    this.opcode('pushLiteral', bool.value);\n  },\n  UndefinedLiteral: function UndefinedLiteral() {\n    this.opcode('pushLiteral', 'undefined');\n  },\n  NullLiteral: function NullLiteral() {\n    this.opcode('pushLiteral', 'null');\n  },\n  Hash: function Hash(hash) {\n    var pairs = hash.pairs,\n        i = 0,\n        l = pairs.length;\n    this.opcode('pushHash');\n\n    for (; i < l; i++) {\n      this.pushParam(pairs[i].value);\n    }\n\n    while (i--) {\n      this.opcode('assignToHash', pairs[i].key);\n    }\n\n    this.opcode('popHash');\n  },\n  // HELPERS\n  opcode: function opcode(name) {\n    this.opcodes.push({\n      opcode: name,\n      args: slice.call(arguments, 1),\n      loc: this.sourceNode[0].loc\n    });\n  },\n  addDepth: function addDepth(depth) {\n    if (!depth) {\n      return;\n    }\n\n    this.useDepths = true;\n  },\n  classifySexpr: function classifySexpr(sexpr) {\n    var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);\n\n    var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]); // a mustache is an eligible helper if:\n    // * its id is simple (a single part, not `this` or `..`)\n\n    var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr); // if a mustache is an eligible helper but not a definite\n    // helper, it is ambiguous, and will be resolved in a later\n    // pass or at runtime.\n\n\n    var isEligible = !isBlockParam && (isHelper || isSimple); // if ambiguous, we can possibly resolve the ambiguity now\n    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.\n\n    if (isEligible && !isHelper) {\n      var _name = sexpr.path.parts[0],\n          options = this.options;\n\n      if (options.knownHelpers[_name]) {\n        isHelper = true;\n      } else if (options.knownHelpersOnly) {\n        isEligible = false;\n      }\n    }\n\n    if (isHelper) {\n      return 'helper';\n    } else if (isEligible) {\n      return 'ambiguous';\n    } else {\n      return 'simple';\n    }\n  },\n  pushParams: function pushParams(params) {\n    for (var i = 0, l = params.length; i < l; i++) {\n      this.pushParam(params[i]);\n    }\n  },\n  pushParam: function pushParam(val) {\n    var value = val.value != null ? val.value : val.original || '';\n\n    if (this.stringParams) {\n      if (value.replace) {\n        value = value.replace(/^(\\.?\\.\\/)*/g, '').replace(/\\//g, '.');\n      }\n\n      if (val.depth) {\n        this.addDepth(val.depth);\n      }\n\n      this.opcode('getContext', val.depth || 0);\n      this.opcode('pushStringParam', value, val.type);\n\n      if (val.type === 'SubExpression') {\n        // SubExpressions get evaluated and passed in\n        // in string params mode.\n        this.accept(val);\n      }\n    } else {\n      if (this.trackIds) {\n        var blockParamIndex = undefined;\n\n        if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {\n          blockParamIndex = this.blockParamIndex(val.parts[0]);\n        }\n\n        if (blockParamIndex) {\n          var blockParamChild = val.parts.slice(1).join('.');\n          this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);\n        } else {\n          value = val.original || value;\n\n          if (value.replace) {\n            value = value.replace(/^this(?:\\.|$)/, '').replace(/^\\.\\//, '').replace(/^\\.$/, '');\n          }\n\n          this.opcode('pushId', val.type, value);\n        }\n      }\n\n      this.accept(val);\n    }\n  },\n  setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {\n    var params = sexpr.params;\n    this.pushParams(params);\n    this.opcode('pushProgram', program);\n    this.opcode('pushProgram', inverse);\n\n    if (sexpr.hash) {\n      this.accept(sexpr.hash);\n    } else {\n      this.opcode('emptyHash', omitEmpty);\n    }\n\n    return params;\n  },\n  blockParamIndex: function blockParamIndex(name) {\n    for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {\n      var blockParams = this.options.blockParams[depth],\n          param = blockParams && _utils.indexOf(blockParams, name);\n\n      if (blockParams && param >= 0) {\n        return [depth, param];\n      }\n    }\n  }\n};\n\nfunction precompile(input, options, env) {\n  if (input == null || typeof input !== 'string' && input.type !== 'Program') {\n    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);\n  }\n\n  options = options || {};\n\n  if (!('data' in options)) {\n    options.data = true;\n  }\n\n  if (options.compat) {\n    options.useDepths = true;\n  }\n\n  var ast = env.parse(input, options),\n      environment = new env.Compiler().compile(ast, options);\n  return new env.JavaScriptCompiler().compile(environment, options);\n}\n\nfunction compile(input, options, env) {\n  if (options === undefined) options = {};\n\n  if (input == null || typeof input !== 'string' && input.type !== 'Program') {\n    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);\n  }\n\n  options = _utils.extend({}, options);\n\n  if (!('data' in options)) {\n    options.data = true;\n  }\n\n  if (options.compat) {\n    options.useDepths = true;\n  }\n\n  var compiled = undefined;\n\n  function compileInput() {\n    var ast = env.parse(input, options),\n        environment = new env.Compiler().compile(ast, options),\n        templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);\n    return env.template(templateSpec);\n  } // Template is only compiled on first use and cached after that point.\n\n\n  function ret(context, execOptions) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n\n    return compiled.call(this, context, execOptions);\n  }\n\n  ret._setup = function (setupOptions) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n\n    return compiled._setup(setupOptions);\n  };\n\n  ret._child = function (i, data, blockParams, depths) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n\n    return compiled._child(i, data, blockParams, depths);\n  };\n\n  return ret;\n}\n\nfunction argEquals(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {\n    for (var i = 0; i < a.length; i++) {\n      if (!argEquals(a[i], b[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n\nfunction transformLiteralToPath(sexpr) {\n  if (!sexpr.path.parts) {\n    var literal = sexpr.path; // Casting to string here to make false and 0 literal values play nicely with the rest\n    // of the system.\n\n    sexpr.path = {\n      type: 'PathExpression',\n      data: false,\n      depth: 0,\n      parts: [literal.original + ''],\n      original: literal.original + '',\n      loc: literal.loc\n    };\n  }\n}","map":{"version":3,"mappings":"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","names":["slice","Compiler","prototype","compiler","equals","other","len","opcodes","length","i","opcode","otherOpcode","argEquals","args","children","guid","compile","program","options","sourceNode","stringParams","trackIds","blockParams","knownHelpers","_utils","Object","create","helperMissing","blockHelperMissing","each","unless","log","lookup","accept","compileProgram","childCompiler","result","usePartial","useDepths","node","type","unshift","ret","shift","Program","body","bodyLength","isSimple","BlockStatement","block","transformLiteralToPath","inverse","classifySexpr","helperSexpr","simpleSexpr","path","original","ambiguousSexpr","DecoratorBlock","decorator","params","setupFullMustacheParams","undefined","useDecorators","PartialStatement","partial","explicitPartialContext","push","parts","depth","partialName","name","isDynamic","indent","preventIndent","PartialBlockStatement","partialBlock","MustacheStatement","mustache","SubExpression","escaped","noEscape","Decorator","ContentStatement","content","value","CommentStatement","sexpr","isBlock","strict","knownHelpersOnly","falsy","_ast2","helpers","simpleId","PathExpression","addDepth","scoped","scopedId","blockParamId","blockParamIndex","data","StringLiteral","string","NumberLiteral","number","BooleanLiteral","bool","UndefinedLiteral","NullLiteral","Hash","hash","pairs","l","pushParam","key","call","arguments","loc","isBlockParam","isHelper","helperExpression","isEligible","_name","pushParams","val","replace","blockParamChild","join","omitEmpty","param","precompile","input","env","compat","ast","parse","environment","JavaScriptCompiler","compiled","compileInput","templateSpec","template","context","execOptions","_setup","setupOptions","_child","depths","a","b","literal"],"sources":["../../../../lib/handlebars/compiler/compiler.js"],"sourcesContent":["/* eslint-disable new-cap */\n\nimport Exception from '../exception';\nimport { isArray, indexOf, extend } from '../utils';\nimport AST from './ast';\n\nconst slice = [].slice;\n\nexport function Compiler() {}\n\n// the foundHelper register will disambiguate helper lookup from finding a\n// function in a context. This is necessary for mustache compatibility, which\n// requires that context functions in blocks are evaluated by blockHelperMissing,\n// and then proceed as if the resulting value was provided to blockHelperMissing.\n\nCompiler.prototype = {\n  compiler: Compiler,\n\n  equals: function(other) {\n    let len = this.opcodes.length;\n    if (other.opcodes.length !== len) {\n      return false;\n    }\n\n    for (let i = 0; i < len; i++) {\n      let opcode = this.opcodes[i],\n        otherOpcode = other.opcodes[i];\n      if (\n        opcode.opcode !== otherOpcode.opcode ||\n        !argEquals(opcode.args, otherOpcode.args)\n      ) {\n        return false;\n      }\n    }\n\n    // We know that length is the same between the two arrays because they are directly tied\n    // to the opcode behavior above.\n    len = this.children.length;\n    for (let i = 0; i < len; i++) {\n      if (!this.children[i].equals(other.children[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  guid: 0,\n\n  compile: function(program, options) {\n    this.sourceNode = [];\n    this.opcodes = [];\n    this.children = [];\n    this.options = options;\n    this.stringParams = options.stringParams;\n    this.trackIds = options.trackIds;\n\n    options.blockParams = options.blockParams || [];\n\n    options.knownHelpers = extend(\n      Object.create(null),\n      {\n        helperMissing: true,\n        blockHelperMissing: true,\n        each: true,\n        if: true,\n        unless: true,\n        with: true,\n        log: true,\n        lookup: true\n      },\n      options.knownHelpers\n    );\n\n    return this.accept(program);\n  },\n\n  compileProgram: function(program) {\n    let childCompiler = new this.compiler(), // eslint-disable-line new-cap\n      result = childCompiler.compile(program, this.options),\n      guid = this.guid++;\n\n    this.usePartial = this.usePartial || result.usePartial;\n\n    this.children[guid] = result;\n    this.useDepths = this.useDepths || result.useDepths;\n\n    return guid;\n  },\n\n  accept: function(node) {\n    /* istanbul ignore next: Sanity code */\n    if (!this[node.type]) {\n      throw new Exception('Unknown type: ' + node.type, node);\n    }\n\n    this.sourceNode.unshift(node);\n    let ret = this[node.type](node);\n    this.sourceNode.shift();\n    return ret;\n  },\n\n  Program: function(program) {\n    this.options.blockParams.unshift(program.blockParams);\n\n    let body = program.body,\n      bodyLength = body.length;\n    for (let i = 0; i < bodyLength; i++) {\n      this.accept(body[i]);\n    }\n\n    this.options.blockParams.shift();\n\n    this.isSimple = bodyLength === 1;\n    this.blockParams = program.blockParams ? program.blockParams.length : 0;\n\n    return this;\n  },\n\n  BlockStatement: function(block) {\n    transformLiteralToPath(block);\n\n    let program = block.program,\n      inverse = block.inverse;\n\n    program = program && this.compileProgram(program);\n    inverse = inverse && this.compileProgram(inverse);\n\n    let type = this.classifySexpr(block);\n\n    if (type === 'helper') {\n      this.helperSexpr(block, program, inverse);\n    } else if (type === 'simple') {\n      this.simpleSexpr(block);\n\n      // now that the simple mustache is resolved, we need to\n      // evaluate it by executing `blockHelperMissing`\n      this.opcode('pushProgram', program);\n      this.opcode('pushProgram', inverse);\n      this.opcode('emptyHash');\n      this.opcode('blockValue', block.path.original);\n    } else {\n      this.ambiguousSexpr(block, program, inverse);\n\n      // now that the simple mustache is resolved, we need to\n      // evaluate it by executing `blockHelperMissing`\n      this.opcode('pushProgram', program);\n      this.opcode('pushProgram', inverse);\n      this.opcode('emptyHash');\n      this.opcode('ambiguousBlockValue');\n    }\n\n    this.opcode('append');\n  },\n\n  DecoratorBlock(decorator) {\n    let program = decorator.program && this.compileProgram(decorator.program);\n    let params = this.setupFullMustacheParams(decorator, program, undefined),\n      path = decorator.path;\n\n    this.useDecorators = true;\n    this.opcode('registerDecorator', params.length, path.original);\n  },\n\n  PartialStatement: function(partial) {\n    this.usePartial = true;\n\n    let program = partial.program;\n    if (program) {\n      program = this.compileProgram(partial.program);\n    }\n\n    let params = partial.params;\n    if (params.length > 1) {\n      throw new Exception(\n        'Unsupported number of partial arguments: ' + params.length,\n        partial\n      );\n    } else if (!params.length) {\n      if (this.options.explicitPartialContext) {\n        this.opcode('pushLiteral', 'undefined');\n      } else {\n        params.push({ type: 'PathExpression', parts: [], depth: 0 });\n      }\n    }\n\n    let partialName = partial.name.original,\n      isDynamic = partial.name.type === 'SubExpression';\n    if (isDynamic) {\n      this.accept(partial.name);\n    }\n\n    this.setupFullMustacheParams(partial, program, undefined, true);\n\n    let indent = partial.indent || '';\n    if (this.options.preventIndent && indent) {\n      this.opcode('appendContent', indent);\n      indent = '';\n    }\n\n    this.opcode('invokePartial', isDynamic, partialName, indent);\n    this.opcode('append');\n  },\n  PartialBlockStatement: function(partialBlock) {\n    this.PartialStatement(partialBlock);\n  },\n\n  MustacheStatement: function(mustache) {\n    this.SubExpression(mustache);\n\n    if (mustache.escaped && !this.options.noEscape) {\n      this.opcode('appendEscaped');\n    } else {\n      this.opcode('append');\n    }\n  },\n  Decorator(decorator) {\n    this.DecoratorBlock(decorator);\n  },\n\n  ContentStatement: function(content) {\n    if (content.value) {\n      this.opcode('appendContent', content.value);\n    }\n  },\n\n  CommentStatement: function() {},\n\n  SubExpression: function(sexpr) {\n    transformLiteralToPath(sexpr);\n    let type = this.classifySexpr(sexpr);\n\n    if (type === 'simple') {\n      this.simpleSexpr(sexpr);\n    } else if (type === 'helper') {\n      this.helperSexpr(sexpr);\n    } else {\n      this.ambiguousSexpr(sexpr);\n    }\n  },\n  ambiguousSexpr: function(sexpr, program, inverse) {\n    let path = sexpr.path,\n      name = path.parts[0],\n      isBlock = program != null || inverse != null;\n\n    this.opcode('getContext', path.depth);\n\n    this.opcode('pushProgram', program);\n    this.opcode('pushProgram', inverse);\n\n    path.strict = true;\n    this.accept(path);\n\n    this.opcode('invokeAmbiguous', name, isBlock);\n  },\n\n  simpleSexpr: function(sexpr) {\n    let path = sexpr.path;\n    path.strict = true;\n    this.accept(path);\n    this.opcode('resolvePossibleLambda');\n  },\n\n  helperSexpr: function(sexpr, program, inverse) {\n    let params = this.setupFullMustacheParams(sexpr, program, inverse),\n      path = sexpr.path,\n      name = path.parts[0];\n\n    if (this.options.knownHelpers[name]) {\n      this.opcode('invokeKnownHelper', params.length, name);\n    } else if (this.options.knownHelpersOnly) {\n      throw new Exception(\n        'You specified knownHelpersOnly, but used the unknown helper ' + name,\n        sexpr\n      );\n    } else {\n      path.strict = true;\n      path.falsy = true;\n\n      this.accept(path);\n      this.opcode(\n        'invokeHelper',\n        params.length,\n        path.original,\n        AST.helpers.simpleId(path)\n      );\n    }\n  },\n\n  PathExpression: function(path) {\n    this.addDepth(path.depth);\n    this.opcode('getContext', path.depth);\n\n    let name = path.parts[0],\n      scoped = AST.helpers.scopedId(path),\n      blockParamId = !path.depth && !scoped && this.blockParamIndex(name);\n\n    if (blockParamId) {\n      this.opcode('lookupBlockParam', blockParamId, path.parts);\n    } else if (!name) {\n      // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`\n      this.opcode('pushContext');\n    } else if (path.data) {\n      this.options.data = true;\n      this.opcode('lookupData', path.depth, path.parts, path.strict);\n    } else {\n      this.opcode(\n        'lookupOnContext',\n        path.parts,\n        path.falsy,\n        path.strict,\n        scoped\n      );\n    }\n  },\n\n  StringLiteral: function(string) {\n    this.opcode('pushString', string.value);\n  },\n\n  NumberLiteral: function(number) {\n    this.opcode('pushLiteral', number.value);\n  },\n\n  BooleanLiteral: function(bool) {\n    this.opcode('pushLiteral', bool.value);\n  },\n\n  UndefinedLiteral: function() {\n    this.opcode('pushLiteral', 'undefined');\n  },\n\n  NullLiteral: function() {\n    this.opcode('pushLiteral', 'null');\n  },\n\n  Hash: function(hash) {\n    let pairs = hash.pairs,\n      i = 0,\n      l = pairs.length;\n\n    this.opcode('pushHash');\n\n    for (; i < l; i++) {\n      this.pushParam(pairs[i].value);\n    }\n    while (i--) {\n      this.opcode('assignToHash', pairs[i].key);\n    }\n    this.opcode('popHash');\n  },\n\n  // HELPERS\n  opcode: function(name) {\n    this.opcodes.push({\n      opcode: name,\n      args: slice.call(arguments, 1),\n      loc: this.sourceNode[0].loc\n    });\n  },\n\n  addDepth: function(depth) {\n    if (!depth) {\n      return;\n    }\n\n    this.useDepths = true;\n  },\n\n  classifySexpr: function(sexpr) {\n    let isSimple = AST.helpers.simpleId(sexpr.path);\n\n    let isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);\n\n    // a mustache is an eligible helper if:\n    // * its id is simple (a single part, not `this` or `..`)\n    let isHelper = !isBlockParam && AST.helpers.helperExpression(sexpr);\n\n    // if a mustache is an eligible helper but not a definite\n    // helper, it is ambiguous, and will be resolved in a later\n    // pass or at runtime.\n    let isEligible = !isBlockParam && (isHelper || isSimple);\n\n    // if ambiguous, we can possibly resolve the ambiguity now\n    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.\n    if (isEligible && !isHelper) {\n      let name = sexpr.path.parts[0],\n        options = this.options;\n      if (options.knownHelpers[name]) {\n        isHelper = true;\n      } else if (options.knownHelpersOnly) {\n        isEligible = false;\n      }\n    }\n\n    if (isHelper) {\n      return 'helper';\n    } else if (isEligible) {\n      return 'ambiguous';\n    } else {\n      return 'simple';\n    }\n  },\n\n  pushParams: function(params) {\n    for (let i = 0, l = params.length; i < l; i++) {\n      this.pushParam(params[i]);\n    }\n  },\n\n  pushParam: function(val) {\n    let value = val.value != null ? val.value : val.original || '';\n\n    if (this.stringParams) {\n      if (value.replace) {\n        value = value.replace(/^(\\.?\\.\\/)*/g, '').replace(/\\//g, '.');\n      }\n\n      if (val.depth) {\n        this.addDepth(val.depth);\n      }\n      this.opcode('getContext', val.depth || 0);\n      this.opcode('pushStringParam', value, val.type);\n\n      if (val.type === 'SubExpression') {\n        // SubExpressions get evaluated and passed in\n        // in string params mode.\n        this.accept(val);\n      }\n    } else {\n      if (this.trackIds) {\n        let blockParamIndex;\n        if (val.parts && !AST.helpers.scopedId(val) && !val.depth) {\n          blockParamIndex = this.blockParamIndex(val.parts[0]);\n        }\n        if (blockParamIndex) {\n          let blockParamChild = val.parts.slice(1).join('.');\n          this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);\n        } else {\n          value = val.original || value;\n          if (value.replace) {\n            value = value\n              .replace(/^this(?:\\.|$)/, '')\n              .replace(/^\\.\\//, '')\n              .replace(/^\\.$/, '');\n          }\n\n          this.opcode('pushId', val.type, value);\n        }\n      }\n      this.accept(val);\n    }\n  },\n\n  setupFullMustacheParams: function(sexpr, program, inverse, omitEmpty) {\n    let params = sexpr.params;\n    this.pushParams(params);\n\n    this.opcode('pushProgram', program);\n    this.opcode('pushProgram', inverse);\n\n    if (sexpr.hash) {\n      this.accept(sexpr.hash);\n    } else {\n      this.opcode('emptyHash', omitEmpty);\n    }\n\n    return params;\n  },\n\n  blockParamIndex: function(name) {\n    for (\n      let depth = 0, len = this.options.blockParams.length;\n      depth < len;\n      depth++\n    ) {\n      let blockParams = this.options.blockParams[depth],\n        param = blockParams && indexOf(blockParams, name);\n      if (blockParams && param >= 0) {\n        return [depth, param];\n      }\n    }\n  }\n};\n\nexport function precompile(input, options, env) {\n  if (\n    input == null ||\n    (typeof input !== 'string' && input.type !== 'Program')\n  ) {\n    throw new Exception(\n      'You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' +\n        input\n    );\n  }\n\n  options = options || {};\n  if (!('data' in options)) {\n    options.data = true;\n  }\n  if (options.compat) {\n    options.useDepths = true;\n  }\n\n  let ast = env.parse(input, options),\n    environment = new env.Compiler().compile(ast, options);\n  return new env.JavaScriptCompiler().compile(environment, options);\n}\n\nexport function compile(input, options = {}, env) {\n  if (\n    input == null ||\n    (typeof input !== 'string' && input.type !== 'Program')\n  ) {\n    throw new Exception(\n      'You must pass a string or Handlebars AST to Handlebars.compile. You passed ' +\n        input\n    );\n  }\n\n  options = extend({}, options);\n  if (!('data' in options)) {\n    options.data = true;\n  }\n  if (options.compat) {\n    options.useDepths = true;\n  }\n\n  let compiled;\n\n  function compileInput() {\n    let ast = env.parse(input, options),\n      environment = new env.Compiler().compile(ast, options),\n      templateSpec = new env.JavaScriptCompiler().compile(\n        environment,\n        options,\n        undefined,\n        true\n      );\n    return env.template(templateSpec);\n  }\n\n  // Template is only compiled on first use and cached after that point.\n  function ret(context, execOptions) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n    return compiled.call(this, context, execOptions);\n  }\n  ret._setup = function(setupOptions) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n    return compiled._setup(setupOptions);\n  };\n  ret._child = function(i, data, blockParams, depths) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n    return compiled._child(i, data, blockParams, depths);\n  };\n  return ret;\n}\n\nfunction argEquals(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (isArray(a) && isArray(b) && a.length === b.length) {\n    for (let i = 0; i < a.length; i++) {\n      if (!argEquals(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\nfunction transformLiteralToPath(sexpr) {\n  if (!sexpr.path.parts) {\n    let literal = sexpr.path;\n    // Casting to string here to make false and 0 literal values play nicely with the rest\n    // of the system.\n    sexpr.path = {\n      type: 'PathExpression',\n      data: false,\n      depth: 0,\n      parts: [literal.original + ''],\n      original: literal.original + '',\n      loc: literal.loc\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"script"}