{"ast":null,"code":"import { voidMap } from '../parser/tokenizer-event-handlers';\nimport { isLiteral } from '../utils';\nimport { escapeText, escapeAttrValue } from './util';\n\nfunction unreachable() {\n  throw new Error('unreachable');\n}\n\nexport default function build(ast) {\n  if (!ast) {\n    return '';\n  }\n\n  const output = [];\n\n  switch (ast.type) {\n    case 'Program':\n      {\n        const chainBlock = ast['chained'] && ast.body[0];\n\n        if (chainBlock) {\n          chainBlock['chained'] = true;\n        }\n\n        const body = buildEach(ast.body).join('');\n        output.push(body);\n      }\n      break;\n\n    case 'ElementNode':\n      output.push('<', ast.tag);\n\n      if (ast.attributes.length) {\n        output.push(' ', buildEach(ast.attributes).join(' '));\n      }\n\n      if (ast.modifiers.length) {\n        output.push(' ', buildEach(ast.modifiers).join(' '));\n      }\n\n      if (ast.comments.length) {\n        output.push(' ', buildEach(ast.comments).join(' '));\n      }\n\n      if (ast.blockParams.length) {\n        output.push(' ', 'as', ' ', `|${ast.blockParams.join(' ')}|`);\n      }\n\n      if (voidMap[ast.tag]) {\n        if (ast.selfClosing) {\n          output.push(' /');\n        }\n\n        output.push('>');\n      } else {\n        output.push('>');\n        output.push.apply(output, buildEach(ast.children));\n        output.push('</', ast.tag, '>');\n      }\n\n      break;\n\n    case 'AttrNode':\n      if (ast.value.type === 'TextNode') {\n        if (ast.value.chars !== '') {\n          output.push(ast.name, '=');\n          output.push('\"', escapeAttrValue(ast.value.chars), '\"');\n        } else {\n          output.push(ast.name);\n        }\n      } else {\n        output.push(ast.name, '='); // ast.value is mustache or concat\n\n        output.push(build(ast.value));\n      }\n\n      break;\n\n    case 'ConcatStatement':\n      output.push('\"');\n      ast.parts.forEach(node => {\n        if (node.type === 'TextNode') {\n          output.push(escapeAttrValue(node.chars));\n        } else {\n          output.push(build(node));\n        }\n      });\n      output.push('\"');\n      break;\n\n    case 'TextNode':\n      output.push(escapeText(ast.chars));\n      break;\n\n    case 'MustacheStatement':\n      {\n        output.push(compactJoin(['{{', pathParams(ast), '}}']));\n      }\n      break;\n\n    case 'MustacheCommentStatement':\n      {\n        output.push(compactJoin(['{{!--', ast.value, '--}}']));\n      }\n      break;\n\n    case 'ElementModifierStatement':\n      {\n        output.push(compactJoin(['{{', pathParams(ast), '}}']));\n      }\n      break;\n\n    case 'PathExpression':\n      output.push(ast.original);\n      break;\n\n    case 'SubExpression':\n      {\n        output.push('(', pathParams(ast), ')');\n      }\n      break;\n\n    case 'BooleanLiteral':\n      output.push(ast.value ? 'true' : 'false');\n      break;\n\n    case 'BlockStatement':\n      {\n        const lines = [];\n\n        if (ast['chained']) {\n          lines.push(['{{else ', pathParams(ast), '}}'].join(''));\n        } else {\n          lines.push(openBlock(ast));\n        }\n\n        lines.push(build(ast.program));\n\n        if (ast.inverse) {\n          if (!ast.inverse['chained']) {\n            lines.push('{{else}}');\n          }\n\n          lines.push(build(ast.inverse));\n        }\n\n        if (!ast['chained']) {\n          lines.push(closeBlock(ast));\n        }\n\n        output.push(lines.join(''));\n      }\n      break;\n\n    case 'PartialStatement':\n      {\n        output.push(compactJoin(['{{>', pathParams(ast), '}}']));\n      }\n      break;\n\n    case 'CommentStatement':\n      {\n        output.push(compactJoin(['<!--', ast.value, '-->']));\n      }\n      break;\n\n    case 'StringLiteral':\n      {\n        output.push(`\"${ast.value}\"`);\n      }\n      break;\n\n    case 'NumberLiteral':\n      {\n        output.push(String(ast.value));\n      }\n      break;\n\n    case 'UndefinedLiteral':\n      {\n        output.push('undefined');\n      }\n      break;\n\n    case 'NullLiteral':\n      {\n        output.push('null');\n      }\n      break;\n\n    case 'Hash':\n      {\n        output.push(ast.pairs.map(pair => {\n          return build(pair);\n        }).join(' '));\n      }\n      break;\n\n    case 'HashPair':\n      {\n        output.push(`${ast.key}=${build(ast.value)}`);\n      }\n      break;\n  }\n\n  return output.join('');\n}\n\nfunction compact(array) {\n  const newArray = [];\n  array.forEach(a => {\n    if (typeof a !== 'undefined' && a !== null && a !== '') {\n      newArray.push(a);\n    }\n  });\n  return newArray;\n}\n\nfunction buildEach(asts) {\n  return asts.map(build);\n}\n\nfunction pathParams(ast) {\n  let path;\n\n  switch (ast.type) {\n    case 'MustacheStatement':\n    case 'SubExpression':\n    case 'ElementModifierStatement':\n    case 'BlockStatement':\n      if (isLiteral(ast.path)) {\n        return String(ast.path.value);\n      }\n\n      path = build(ast.path);\n      break;\n\n    case 'PartialStatement':\n      path = build(ast.name);\n      break;\n\n    default:\n      return unreachable();\n  }\n\n  return compactJoin([path, buildEach(ast.params).join(' '), build(ast.hash)], ' ');\n}\n\nfunction compactJoin(array, delimiter) {\n  return compact(array).join(delimiter || '');\n}\n\nfunction blockParams(block) {\n  const params = block.program.blockParams;\n\n  if (params.length) {\n    return ` as |${params.join(' ')}|`;\n  }\n\n  return null;\n}\n\nfunction openBlock(block) {\n  return ['{{#', pathParams(block), blockParams(block), '}}'].join('');\n}\n\nfunction closeBlock(block) {\n  return ['{{/', build(block.path), '}}'].join('');\n}","map":{"version":3,"mappings":"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","names":["voidMap","isLiteral","escapeText","escapeAttrValue","unreachable","Error","build","ast","output","type","chainBlock","body","buildEach","join","push","tag","attributes","length","modifiers","comments","blockParams","selfClosing","apply","children","value","chars","name","parts","forEach","node","compactJoin","pathParams","original","lines","openBlock","program","inverse","closeBlock","String","pairs","map","pair","key","compact","array","newArray","a","asts","path","params","hash","delimiter","block"],"sourceRoot":"","sources":["../../../../../packages/@glimmer/syntax/lib/generation/print.ts"],"sourcesContent":["import { Option } from '@glimmer/interfaces';\nimport * as HBS from '../types/nodes';\nimport { voidMap } from '../parser/tokenizer-event-handlers';\nimport { isLiteral } from '../utils';\nimport { escapeText, escapeAttrValue } from './util';\n\nfunction unreachable(): never {\n  throw new Error('unreachable');\n}\n\nexport default function build(ast: HBS.Node): string {\n  if (!ast) {\n    return '';\n  }\n  const output: string[] = [];\n\n  switch (ast.type) {\n    case 'Program':\n      {\n        const chainBlock = ast['chained'] && ast.body[0];\n        if (chainBlock) {\n          chainBlock['chained'] = true;\n        }\n        const body = buildEach(ast.body).join('');\n        output.push(body);\n      }\n      break;\n    case 'ElementNode':\n      output.push('<', ast.tag);\n      if (ast.attributes.length) {\n        output.push(' ', buildEach(ast.attributes).join(' '));\n      }\n      if (ast.modifiers.length) {\n        output.push(' ', buildEach(ast.modifiers).join(' '));\n      }\n      if (ast.comments.length) {\n        output.push(' ', buildEach(ast.comments).join(' '));\n      }\n\n      if (ast.blockParams.length) {\n        output.push(' ', 'as', ' ', `|${ast.blockParams.join(' ')}|`);\n      }\n\n      if (voidMap[ast.tag]) {\n        if (ast.selfClosing) {\n          output.push(' /');\n        }\n\n        output.push('>');\n      } else {\n        output.push('>');\n        output.push.apply(output, buildEach(ast.children));\n        output.push('</', ast.tag, '>');\n      }\n      break;\n    case 'AttrNode':\n      if (ast.value.type === 'TextNode') {\n        if (ast.value.chars !== '') {\n          output.push(ast.name, '=');\n          output.push('\"', escapeAttrValue(ast.value.chars), '\"');\n        } else {\n          output.push(ast.name);\n        }\n      } else {\n        output.push(ast.name, '=');\n        // ast.value is mustache or concat\n        output.push(build(ast.value));\n      }\n      break;\n    case 'ConcatStatement':\n      output.push('\"');\n      ast.parts.forEach((node: HBS.TextNode | HBS.MustacheStatement) => {\n        if (node.type === 'TextNode') {\n          output.push(escapeAttrValue(node.chars));\n        } else {\n          output.push(build(node));\n        }\n      });\n      output.push('\"');\n      break;\n    case 'TextNode':\n      output.push(escapeText(ast.chars));\n      break;\n    case 'MustacheStatement':\n      {\n        output.push(compactJoin(['{{', pathParams(ast), '}}']));\n      }\n      break;\n    case 'MustacheCommentStatement':\n      {\n        output.push(compactJoin(['{{!--', ast.value, '--}}']));\n      }\n      break;\n    case 'ElementModifierStatement':\n      {\n        output.push(compactJoin(['{{', pathParams(ast), '}}']));\n      }\n      break;\n    case 'PathExpression':\n      output.push(ast.original);\n      break;\n    case 'SubExpression':\n      {\n        output.push('(', pathParams(ast), ')');\n      }\n      break;\n    case 'BooleanLiteral':\n      output.push(ast.value ? 'true' : 'false');\n      break;\n    case 'BlockStatement':\n      {\n        const lines: string[] = [];\n\n        if (ast['chained']) {\n          lines.push(['{{else ', pathParams(ast), '}}'].join(''));\n        } else {\n          lines.push(openBlock(ast));\n        }\n\n        lines.push(build(ast.program));\n\n        if (ast.inverse) {\n          if (!ast.inverse['chained']) {\n            lines.push('{{else}}');\n          }\n          lines.push(build(ast.inverse));\n        }\n\n        if (!ast['chained']) {\n          lines.push(closeBlock(ast));\n        }\n\n        output.push(lines.join(''));\n      }\n      break;\n    case 'PartialStatement':\n      {\n        output.push(compactJoin(['{{>', pathParams(ast), '}}']));\n      }\n      break;\n    case 'CommentStatement':\n      {\n        output.push(compactJoin(['<!--', ast.value, '-->']));\n      }\n      break;\n    case 'StringLiteral':\n      {\n        output.push(`\"${ast.value}\"`);\n      }\n      break;\n    case 'NumberLiteral':\n      {\n        output.push(String(ast.value));\n      }\n      break;\n    case 'UndefinedLiteral':\n      {\n        output.push('undefined');\n      }\n      break;\n    case 'NullLiteral':\n      {\n        output.push('null');\n      }\n      break;\n    case 'Hash':\n      {\n        output.push(\n          ast.pairs\n            .map(pair => {\n              return build(pair);\n            })\n            .join(' ')\n        );\n      }\n      break;\n    case 'HashPair':\n      {\n        output.push(`${ast.key}=${build(ast.value)}`);\n      }\n      break;\n  }\n  return output.join('');\n}\n\nfunction compact(array: Option<string>[]): string[] {\n  const newArray: any[] = [];\n  array.forEach(a => {\n    if (typeof a !== 'undefined' && a !== null && a !== '') {\n      newArray.push(a);\n    }\n  });\n  return newArray;\n}\n\nfunction buildEach(asts: HBS.Node[]): string[] {\n  return asts.map(build);\n}\n\nfunction pathParams(ast: HBS.Node): string {\n  let path: string;\n\n  switch (ast.type) {\n    case 'MustacheStatement':\n    case 'SubExpression':\n    case 'ElementModifierStatement':\n    case 'BlockStatement':\n      if (isLiteral(ast.path)) {\n        return String(ast.path.value);\n      }\n\n      path = build(ast.path);\n      break;\n    case 'PartialStatement':\n      path = build(ast.name);\n      break;\n    default:\n      return unreachable();\n  }\n\n  return compactJoin([path, buildEach(ast.params).join(' '), build(ast.hash)], ' ');\n}\n\nfunction compactJoin(array: Option<string>[], delimiter?: string): string {\n  return compact(array).join(delimiter || '');\n}\n\nfunction blockParams(block: HBS.BlockStatement): Option<string> {\n  const params = block.program.blockParams;\n  if (params.length) {\n    return ` as |${params.join(' ')}|`;\n  }\n\n  return null;\n}\n\nfunction openBlock(block: HBS.BlockStatement): string {\n  return ['{{#', pathParams(block), blockParams(block), '}}'].join('');\n}\n\nfunction closeBlock(block: any): string {\n  return ['{{/', build(block.path), '}}'].join('');\n}\n"]},"metadata":{},"sourceType":"module"}