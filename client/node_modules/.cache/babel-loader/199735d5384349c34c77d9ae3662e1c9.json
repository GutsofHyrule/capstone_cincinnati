{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.SourceLocation = SourceLocation;\nexports.id = id;\nexports.stripFlags = stripFlags;\nexports.stripComment = stripComment;\nexports.preparePath = preparePath;\nexports.prepareMustache = prepareMustache;\nexports.prepareRawBlock = prepareRawBlock;\nexports.prepareBlock = prepareBlock;\nexports.prepareProgram = prepareProgram;\nexports.preparePartialBlock = preparePartialBlock; // istanbul ignore next\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar _exception = require('../exception');\n\nvar _exception2 = _interopRequireDefault(_exception);\n\nfunction validateClose(open, close) {\n  close = close.path ? close.path.original : close;\n\n  if (open.path.original !== close) {\n    var errorNode = {\n      loc: open.path.loc\n    };\n    throw new _exception2['default'](open.path.original + \" doesn't match \" + close, errorNode);\n  }\n}\n\nfunction SourceLocation(source, locInfo) {\n  this.source = source;\n  this.start = {\n    line: locInfo.first_line,\n    column: locInfo.first_column\n  };\n  this.end = {\n    line: locInfo.last_line,\n    column: locInfo.last_column\n  };\n}\n\nfunction id(token) {\n  if (/^\\[.*\\]$/.test(token)) {\n    return token.substring(1, token.length - 1);\n  } else {\n    return token;\n  }\n}\n\nfunction stripFlags(open, close) {\n  return {\n    open: open.charAt(2) === '~',\n    close: close.charAt(close.length - 3) === '~'\n  };\n}\n\nfunction stripComment(comment) {\n  return comment.replace(/^\\{\\{~?!-?-?/, '').replace(/-?-?~?\\}\\}$/, '');\n}\n\nfunction preparePath(data, parts, loc) {\n  loc = this.locInfo(loc);\n  var original = data ? '@' : '',\n      dig = [],\n      depth = 0;\n\n  for (var i = 0, l = parts.length; i < l; i++) {\n    var part = parts[i].part,\n        // If we have [] syntax then we do not treat path references as operators,\n    // i.e. foo.[this] resolves to approximately context.foo['this']\n    isLiteral = parts[i].original !== part;\n    original += (parts[i].separator || '') + part;\n\n    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {\n      if (dig.length > 0) {\n        throw new _exception2['default']('Invalid path: ' + original, {\n          loc: loc\n        });\n      } else if (part === '..') {\n        depth++;\n      }\n    } else {\n      dig.push(part);\n    }\n  }\n\n  return {\n    type: 'PathExpression',\n    data: data,\n    depth: depth,\n    parts: dig,\n    original: original,\n    loc: loc\n  };\n}\n\nfunction prepareMustache(path, params, hash, open, strip, locInfo) {\n  // Must use charAt to support IE pre-10\n  var escapeFlag = open.charAt(3) || open.charAt(2),\n      escaped = escapeFlag !== '{' && escapeFlag !== '&';\n  var decorator = /\\*/.test(open);\n  return {\n    type: decorator ? 'Decorator' : 'MustacheStatement',\n    path: path,\n    params: params,\n    hash: hash,\n    escaped: escaped,\n    strip: strip,\n    loc: this.locInfo(locInfo)\n  };\n}\n\nfunction prepareRawBlock(openRawBlock, contents, close, locInfo) {\n  validateClose(openRawBlock, close);\n  locInfo = this.locInfo(locInfo);\n  var program = {\n    type: 'Program',\n    body: contents,\n    strip: {},\n    loc: locInfo\n  };\n  return {\n    type: 'BlockStatement',\n    path: openRawBlock.path,\n    params: openRawBlock.params,\n    hash: openRawBlock.hash,\n    program: program,\n    openStrip: {},\n    inverseStrip: {},\n    closeStrip: {},\n    loc: locInfo\n  };\n}\n\nfunction prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {\n  if (close && close.path) {\n    validateClose(openBlock, close);\n  }\n\n  var decorator = /\\*/.test(openBlock.open);\n  program.blockParams = openBlock.blockParams;\n  var inverse = undefined,\n      inverseStrip = undefined;\n\n  if (inverseAndProgram) {\n    if (decorator) {\n      throw new _exception2['default']('Unexpected inverse block on decorator', inverseAndProgram);\n    }\n\n    if (inverseAndProgram.chain) {\n      inverseAndProgram.program.body[0].closeStrip = close.strip;\n    }\n\n    inverseStrip = inverseAndProgram.strip;\n    inverse = inverseAndProgram.program;\n  }\n\n  if (inverted) {\n    inverted = inverse;\n    inverse = program;\n    program = inverted;\n  }\n\n  return {\n    type: decorator ? 'DecoratorBlock' : 'BlockStatement',\n    path: openBlock.path,\n    params: openBlock.params,\n    hash: openBlock.hash,\n    program: program,\n    inverse: inverse,\n    openStrip: openBlock.strip,\n    inverseStrip: inverseStrip,\n    closeStrip: close && close.strip,\n    loc: this.locInfo(locInfo)\n  };\n}\n\nfunction prepareProgram(statements, loc) {\n  if (!loc && statements.length) {\n    var firstLoc = statements[0].loc,\n        lastLoc = statements[statements.length - 1].loc;\n    /* istanbul ignore else */\n\n    if (firstLoc && lastLoc) {\n      loc = {\n        source: firstLoc.source,\n        start: {\n          line: firstLoc.start.line,\n          column: firstLoc.start.column\n        },\n        end: {\n          line: lastLoc.end.line,\n          column: lastLoc.end.column\n        }\n      };\n    }\n  }\n\n  return {\n    type: 'Program',\n    body: statements,\n    strip: {},\n    loc: loc\n  };\n}\n\nfunction preparePartialBlock(open, program, close, locInfo) {\n  validateClose(open, close);\n  return {\n    type: 'PartialBlockStatement',\n    name: open.path,\n    params: open.params,\n    hash: open.hash,\n    program: program,\n    openStrip: open.strip,\n    closeStrip: close && close.strip,\n    loc: this.locInfo(locInfo)\n  };\n}","map":{"version":3,"mappings":"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","names":["validateClose","open","close","path","original","errorNode","loc","SourceLocation","source","locInfo","start","line","first_line","column","first_column","end","last_line","last_column","id","token","test","substring","length","stripFlags","charAt","stripComment","comment","replace","preparePath","data","parts","dig","depth","i","l","part","isLiteral","separator","push","type","prepareMustache","params","hash","strip","escapeFlag","escaped","decorator","prepareRawBlock","openRawBlock","contents","program","body","openStrip","inverseStrip","closeStrip","prepareBlock","openBlock","inverseAndProgram","inverted","blockParams","inverse","chain","prepareProgram","statements","firstLoc","lastLoc","preparePartialBlock","name"],"sources":["../../../../lib/handlebars/compiler/helpers.js"],"sourcesContent":["import Exception from '../exception';\n\nfunction validateClose(open, close) {\n  close = close.path ? close.path.original : close;\n\n  if (open.path.original !== close) {\n    let errorNode = { loc: open.path.loc };\n\n    throw new Exception(\n      open.path.original + \" doesn't match \" + close,\n      errorNode\n    );\n  }\n}\n\nexport function SourceLocation(source, locInfo) {\n  this.source = source;\n  this.start = {\n    line: locInfo.first_line,\n    column: locInfo.first_column\n  };\n  this.end = {\n    line: locInfo.last_line,\n    column: locInfo.last_column\n  };\n}\n\nexport function id(token) {\n  if (/^\\[.*\\]$/.test(token)) {\n    return token.substring(1, token.length - 1);\n  } else {\n    return token;\n  }\n}\n\nexport function stripFlags(open, close) {\n  return {\n    open: open.charAt(2) === '~',\n    close: close.charAt(close.length - 3) === '~'\n  };\n}\n\nexport function stripComment(comment) {\n  return comment.replace(/^\\{\\{~?!-?-?/, '').replace(/-?-?~?\\}\\}$/, '');\n}\n\nexport function preparePath(data, parts, loc) {\n  loc = this.locInfo(loc);\n\n  let original = data ? '@' : '',\n    dig = [],\n    depth = 0;\n\n  for (let i = 0, l = parts.length; i < l; i++) {\n    let part = parts[i].part,\n      // If we have [] syntax then we do not treat path references as operators,\n      // i.e. foo.[this] resolves to approximately context.foo['this']\n      isLiteral = parts[i].original !== part;\n    original += (parts[i].separator || '') + part;\n\n    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {\n      if (dig.length > 0) {\n        throw new Exception('Invalid path: ' + original, { loc });\n      } else if (part === '..') {\n        depth++;\n      }\n    } else {\n      dig.push(part);\n    }\n  }\n\n  return {\n    type: 'PathExpression',\n    data,\n    depth,\n    parts: dig,\n    original,\n    loc\n  };\n}\n\nexport function prepareMustache(path, params, hash, open, strip, locInfo) {\n  // Must use charAt to support IE pre-10\n  let escapeFlag = open.charAt(3) || open.charAt(2),\n    escaped = escapeFlag !== '{' && escapeFlag !== '&';\n\n  let decorator = /\\*/.test(open);\n  return {\n    type: decorator ? 'Decorator' : 'MustacheStatement',\n    path,\n    params,\n    hash,\n    escaped,\n    strip,\n    loc: this.locInfo(locInfo)\n  };\n}\n\nexport function prepareRawBlock(openRawBlock, contents, close, locInfo) {\n  validateClose(openRawBlock, close);\n\n  locInfo = this.locInfo(locInfo);\n  let program = {\n    type: 'Program',\n    body: contents,\n    strip: {},\n    loc: locInfo\n  };\n\n  return {\n    type: 'BlockStatement',\n    path: openRawBlock.path,\n    params: openRawBlock.params,\n    hash: openRawBlock.hash,\n    program,\n    openStrip: {},\n    inverseStrip: {},\n    closeStrip: {},\n    loc: locInfo\n  };\n}\n\nexport function prepareBlock(\n  openBlock,\n  program,\n  inverseAndProgram,\n  close,\n  inverted,\n  locInfo\n) {\n  if (close && close.path) {\n    validateClose(openBlock, close);\n  }\n\n  let decorator = /\\*/.test(openBlock.open);\n\n  program.blockParams = openBlock.blockParams;\n\n  let inverse, inverseStrip;\n\n  if (inverseAndProgram) {\n    if (decorator) {\n      throw new Exception(\n        'Unexpected inverse block on decorator',\n        inverseAndProgram\n      );\n    }\n\n    if (inverseAndProgram.chain) {\n      inverseAndProgram.program.body[0].closeStrip = close.strip;\n    }\n\n    inverseStrip = inverseAndProgram.strip;\n    inverse = inverseAndProgram.program;\n  }\n\n  if (inverted) {\n    inverted = inverse;\n    inverse = program;\n    program = inverted;\n  }\n\n  return {\n    type: decorator ? 'DecoratorBlock' : 'BlockStatement',\n    path: openBlock.path,\n    params: openBlock.params,\n    hash: openBlock.hash,\n    program,\n    inverse,\n    openStrip: openBlock.strip,\n    inverseStrip,\n    closeStrip: close && close.strip,\n    loc: this.locInfo(locInfo)\n  };\n}\n\nexport function prepareProgram(statements, loc) {\n  if (!loc && statements.length) {\n    const firstLoc = statements[0].loc,\n      lastLoc = statements[statements.length - 1].loc;\n\n    /* istanbul ignore else */\n    if (firstLoc && lastLoc) {\n      loc = {\n        source: firstLoc.source,\n        start: {\n          line: firstLoc.start.line,\n          column: firstLoc.start.column\n        },\n        end: {\n          line: lastLoc.end.line,\n          column: lastLoc.end.column\n        }\n      };\n    }\n  }\n\n  return {\n    type: 'Program',\n    body: statements,\n    strip: {},\n    loc: loc\n  };\n}\n\nexport function preparePartialBlock(open, program, close, locInfo) {\n  validateClose(open, close);\n\n  return {\n    type: 'PartialBlockStatement',\n    name: open.path,\n    params: open.params,\n    hash: open.hash,\n    program,\n    openStrip: open.strip,\n    closeStrip: close && close.strip,\n    loc: this.locInfo(locInfo)\n  };\n}\n"]},"metadata":{},"sourceType":"script"}