{"ast":null,"code":"function buildMustache(path, params, hash, raw, loc) {\n  if (typeof path === 'string') {\n    path = buildPath(path);\n  }\n\n  return {\n    type: 'MustacheStatement',\n    path,\n    params: params || [],\n    hash: hash || buildHash([]),\n    escaped: !raw,\n    loc: buildLoc(loc || null)\n  };\n}\n\nfunction buildBlock(path, params, hash, program, inverse, loc) {\n  return {\n    type: 'BlockStatement',\n    path: buildPath(path),\n    params: params || [],\n    hash: hash || buildHash([]),\n    program: program || null,\n    inverse: inverse || null,\n    loc: buildLoc(loc || null)\n  };\n}\n\nfunction buildElementModifier(path, params, hash, loc) {\n  return {\n    type: 'ElementModifierStatement',\n    path: buildPath(path),\n    params: params || [],\n    hash: hash || buildHash([]),\n    loc: buildLoc(loc || null)\n  };\n}\n\nfunction buildPartial(name, params, hash, indent, loc) {\n  return {\n    type: 'PartialStatement',\n    name: name,\n    params: params || [],\n    hash: hash || buildHash([]),\n    indent: indent || '',\n    strip: {\n      open: false,\n      close: false\n    },\n    loc: buildLoc(loc || null)\n  };\n}\n\nfunction buildComment(value, loc) {\n  return {\n    type: 'CommentStatement',\n    value: value,\n    loc: buildLoc(loc || null)\n  };\n}\n\nfunction buildMustacheComment(value, loc) {\n  return {\n    type: 'MustacheCommentStatement',\n    value: value,\n    loc: buildLoc(loc || null)\n  };\n}\n\nfunction buildConcat(parts, loc) {\n  return {\n    type: 'ConcatStatement',\n    parts: parts || [],\n    loc: buildLoc(loc || null)\n  };\n}\n\nfunction buildElement(tag, attributes, modifiers, children, comments, blockParams, loc) {\n  // this is used for backwards compat prior to `blockParams` being added to the AST\n  if (Array.isArray(comments)) {\n    if (isBlockParms(comments)) {\n      blockParams = comments;\n      comments = [];\n    } else if (isLoc(blockParams)) {\n      loc = blockParams;\n      blockParams = [];\n    }\n  } else if (isLoc(comments)) {\n    // this is used for backwards compat prior to `comments` being added to the AST\n    loc = comments;\n    comments = [];\n  } else if (isLoc(blockParams)) {\n    loc = blockParams;\n    blockParams = [];\n  } // this is used for backwards compat, prior to `selfClosing` being part of the ElementNode AST\n\n\n  let selfClosing = false;\n\n  if (typeof tag === 'object') {\n    selfClosing = tag.selfClosing;\n    tag = tag.name;\n  }\n\n  return {\n    type: 'ElementNode',\n    tag: tag || '',\n    selfClosing: selfClosing,\n    attributes: attributes || [],\n    blockParams: blockParams || [],\n    modifiers: modifiers || [],\n    comments: comments || [],\n    children: children || [],\n    loc: buildLoc(loc || null)\n  };\n}\n\nfunction buildAttr(name, value, loc) {\n  return {\n    type: 'AttrNode',\n    name: name,\n    value: value,\n    loc: buildLoc(loc || null)\n  };\n}\n\nfunction buildText(chars, loc) {\n  return {\n    type: 'TextNode',\n    chars: chars || '',\n    loc: buildLoc(loc || null)\n  };\n} // Expressions\n\n\nfunction buildSexpr(path, params, hash, loc) {\n  return {\n    type: 'SubExpression',\n    path: buildPath(path),\n    params: params || [],\n    hash: hash || buildHash([]),\n    loc: buildLoc(loc || null)\n  };\n}\n\nfunction buildPath(original, loc) {\n  if (typeof original !== 'string') return original;\n  let parts = original.split('.');\n  let thisHead = false;\n\n  if (parts[0] === 'this') {\n    thisHead = true;\n    parts = parts.slice(1);\n  }\n\n  return {\n    type: 'PathExpression',\n    original,\n    this: thisHead,\n    parts,\n    data: false,\n    loc: buildLoc(loc || null)\n  };\n}\n\nfunction buildLiteral(type, value, loc) {\n  return {\n    type,\n    value,\n    original: value,\n    loc: buildLoc(loc || null)\n  };\n} // Miscellaneous\n\n\nfunction buildHash(pairs, loc) {\n  return {\n    type: 'Hash',\n    pairs: pairs || [],\n    loc: buildLoc(loc || null)\n  };\n}\n\nfunction buildPair(key, value, loc) {\n  return {\n    type: 'HashPair',\n    key: key,\n    value,\n    loc: buildLoc(loc || null)\n  };\n}\n\nfunction buildProgram(body, blockParams, loc) {\n  return {\n    type: 'Program',\n    body: body || [],\n    blockParams: blockParams || [],\n    loc: buildLoc(loc || null)\n  };\n}\n\nfunction buildSource(source) {\n  return source || null;\n}\n\nfunction buildPosition(line, column) {\n  return {\n    line,\n    column\n  };\n}\n\nexport const SYNTHETIC = {\n  source: '(synthetic)',\n  start: {\n    line: 1,\n    column: 0\n  },\n  end: {\n    line: 1,\n    column: 0\n  }\n};\n\nfunction buildLoc() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  if (args.length === 1) {\n    let loc = args[0];\n\n    if (loc && typeof loc === 'object') {\n      return {\n        source: buildSource(loc.source),\n        start: buildPosition(loc.start.line, loc.start.column),\n        end: buildPosition(loc.end.line, loc.end.column)\n      };\n    } else {\n      return SYNTHETIC;\n    }\n  } else {\n    let [startLine, startColumn, endLine, endColumn, source] = args;\n    return {\n      source: buildSource(source),\n      start: buildPosition(startLine, startColumn),\n      end: buildPosition(endLine, endColumn)\n    };\n  }\n}\n\nfunction isBlockParms(arr) {\n  return arr[0] === 'string';\n}\n\nfunction isLoc(item) {\n  return !Array.isArray(item);\n}\n\nexport default {\n  mustache: buildMustache,\n  block: buildBlock,\n  partial: buildPartial,\n  comment: buildComment,\n  mustacheComment: buildMustacheComment,\n  element: buildElement,\n  elementModifier: buildElementModifier,\n  attr: buildAttr,\n  text: buildText,\n  sexpr: buildSexpr,\n  path: buildPath,\n  concat: buildConcat,\n  hash: buildHash,\n  pair: buildPair,\n  literal: buildLiteral,\n  program: buildProgram,\n  loc: buildLoc,\n  pos: buildPosition,\n  string: literal('StringLiteral'),\n  boolean: literal('BooleanLiteral'),\n  number: literal('NumberLiteral'),\n\n  undefined() {\n    return buildLiteral('UndefinedLiteral', undefined);\n  },\n\n  null() {\n    return buildLiteral('NullLiteral', null);\n  }\n\n};\n\nfunction literal(type) {\n  return function (value) {\n    return buildLiteral(type, value);\n  };\n}","map":{"version":3,"mappings":"AAQA,SAASA,aAAT,CACEC,IADF,EAEEC,MAFF,EAGEC,IAHF,EAIEC,GAJF,EAKEC,GALF,EAK0B;EAExB,IAAI,OAAOJ,IAAP,KAAgB,QAApB,EAA8B;IACxBA,OAAGK,SAAS,CAACL,IAAD,CAAZ;EACL;;EAED;IACMM,MAAE,mBADR;IAEMN,IAFN;IAGQC,QAAEA,MAAM,IAAI,EAHpB;IAIMC,MAAEA,IAAI,IAAIK,SAAS,CAAC,EAAD,CAJzB;IAKSC,SAAE,CAACL,GALZ;IAMKC,KAAEK,QAAQ,CAACL,GAAG,IAAI,IAAR;EANf;AAQD;;AAED,SAASM,UAAT,CACEV,IADF,EAEEC,MAFF,EAGEC,IAHF,EAIES,OAJF,EAKEC,OALF,EAMER,GANF,EAM0B;EAExB;IACME,MAAE,gBADR;IAEMN,MAAEK,SAAS,CAACL,IAAD,CAFjB;IAGQC,QAAEA,MAAM,IAAI,EAHpB;IAIMC,MAAEA,IAAI,IAAIK,SAAS,CAAC,EAAD,CAJzB;IAKSI,SAAEA,OAAO,IAAI,IALtB;IAMSC,SAAEA,OAAO,IAAI,IANtB;IAOKR,KAAEK,QAAQ,CAACL,GAAG,IAAI,IAAR;EAPf;AASD;;AAED,SAASS,oBAAT,CACEb,IADF,EAEEC,MAFF,EAGEC,IAHF,EAIEE,GAJF,EAIkC;EAEhC;IACME,MAAE,0BADR;IAEMN,MAAEK,SAAS,CAACL,IAAD,CAFjB;IAGQC,QAAEA,MAAM,IAAI,EAHpB;IAIMC,MAAEA,IAAI,IAAIK,SAAS,CAAC,EAAD,CAJzB;IAKKH,KAAEK,QAAQ,CAACL,GAAG,IAAI,IAAR;EALf;AAOD;;AAED,SAASU,YAAT,CACEC,IADF,EAEEd,MAFF,EAGEC,IAHF,EAIEc,MAJF,EAKEZ,GALF,EAK0B;EAExB;IACME,MAAE,kBADR;IAEMS,MAAEA,IAFR;IAGQd,QAAEA,MAAM,IAAI,EAHpB;IAIMC,MAAEA,IAAI,IAAIK,SAAS,CAAC,EAAD,CAJzB;IAKQS,QAAEA,MAAM,IAAI,EALpB;IAMOC,OAAE;MAAEC,IAAI,EAAE,KAAR;MAAeC,KAAK,EAAE;IAAtB,CANT;IAOKf,KAAEK,QAAQ,CAACL,GAAG,IAAI,IAAR;EAPf;AASD;;AAED,SAASgB,YAAT,CAAsBC,KAAtB,EAAqCjB,GAArC,EAA6D;EAC3D;IACME,MAAE,kBADR;IAEOe,OAAEA,KAFT;IAGKjB,KAAEK,QAAQ,CAACL,GAAG,IAAI,IAAR;EAHf;AAKD;;AAED,SAASkB,oBAAT,CACED,KADF,EAEEjB,GAFF,EAE0B;EAExB;IACME,MAAE,0BADR;IAEOe,OAAEA,KAFT;IAGKjB,KAAEK,QAAQ,CAACL,GAAG,IAAI,IAAR;EAHf;AAKD;;AAED,SAASmB,WAAT,CACEC,KADF,EAEEpB,GAFF,EAE0B;EAExB;IACME,MAAE,iBADR;IAEOkB,OAAEA,KAAK,IAAI,EAFlB;IAGKpB,KAAEK,QAAQ,CAACL,GAAG,IAAI,IAAR;EAHf;AAKD;;AAqBD,SAASqB,YAAT,CACEC,GADF,EAEEC,UAFF,EAGEC,SAHF,EAIEC,QAJF,EAKEC,QALF,EAMEC,WANF,EAOE3B,GAPF,EAO0B;EAE0D;EAClF,IAAI4B,KAAK,CAACC,OAAN,CAAcH,QAAd,CAAJ,EAA6B;IAC3B,IAAII,YAAY,CAACJ,QAAD,CAAhB,EAA4B;MACfC,cAAGD,QAAH;MACHA,WAAG,EAAH;IACT,CAHD,MAGO,IAAIK,KAAK,CAACJ,WAAD,CAAT,EAAwB;MAC1B3B,MAAG2B,WAAH;MACQA,cAAG,EAAH;IACZ;EACF,CARD,MAQC,IAAUI,KAAK,CAACL,QAAD,CAAf,EAA2B;IACqD;IAC5E1B,MAAG0B,QAAH;IACKA,WAAG,EAAH;EAHH,CAAN,MAIM,IAAIK,KAAK,CAACJ,WAAD,CAAT,EAAwB;IAC1B3B,MAAG2B,WAAH;IACQA,cAAG,EAAH;EACZ,CAlBuB,CAoBsE;;;EAC9F,IAAIK,WAAW,GAAG,KAAlB;;EACA,IAAI,OAAOV,GAAP,KAAe,QAAnB,EAA6B;IAChBU,cAAGV,GAAG,CAACU,WAAP;IACRV,MAAGA,GAAG,CAACX,IAAP;EACJ;;EAED;IACMT,MAAE,aADR;IAEKoB,KAAEA,GAAG,IAAI,EAFd;IAGaU,aAAEA,WAHf;IAIYT,YAAEA,UAAU,IAAI,EAJ5B;IAKaI,aAAEA,WAAW,IAAI,EAL9B;IAMWH,WAAEA,SAAS,IAAI,EAN1B;IAOUE,UAAGA,QAA2C,IAAI,EAP5D;IAQUD,UAAEA,QAAQ,IAAI,EARxB;IASKzB,KAAEK,QAAQ,CAACL,GAAG,IAAI,IAAR;EATf;AAWD;;AAED,SAASiC,SAAT,CACEtB,IADF,EAEEM,KAFF,EAGEjB,GAHF,EAG0B;EAExB;IACME,MAAE,UADR;IAEMS,MAAEA,IAFR;IAGOM,OAAEA,KAHT;IAIKjB,KAAEK,QAAQ,CAACL,GAAG,IAAI,IAAR;EAJf;AAMD;;AAED,SAASkC,SAAT,CAAmBC,KAAnB,EAAmCnC,GAAnC,EAA2D;EACzD;IACME,MAAE,UADR;IAEOiC,OAAEA,KAAK,IAAI,EAFlB;IAGKnC,KAAEK,QAAQ,CAACL,GAAG,IAAI,IAAR;EAHf;AAKD,C,CAED;;;AAEA,SAASoC,UAAT,CACExC,IADF,EAEEC,MAFF,EAGEC,IAHF,EAIEE,GAJF,EAI0B;EAExB;IACME,MAAE,eADR;IAEMN,MAAEK,SAAS,CAACL,IAAD,CAFjB;IAGQC,QAAEA,MAAM,IAAI,EAHpB;IAIMC,MAAEA,IAAI,IAAIK,SAAS,CAAC,EAAD,CAJzB;IAKKH,KAAEK,QAAQ,CAACL,GAAG,IAAI,IAAR;EALf;AAOD;;AAED,SAASC,SAAT,CAAmBoC,QAAnB,EAA0CrC,GAA1C,EAAkE;EAChE,IAAI,OAAOqC,QAAP,KAAoB,QAAxB,EAAkC,OAAOA,QAAP;EAElC,IAAIjB,KAAK,GAAGiB,QAAQ,CAACC,KAAT,CAAe,GAAf,CAAZ;EACA,IAAIC,QAAQ,GAAG,KAAf;;EAEA,IAAInB,KAAK,CAAC,CAAD,CAAL,KAAa,MAAjB,EAAyB;IACfmB,WAAG,IAAH;IACHnB,QAAGA,KAAK,CAACoB,KAAN,CAAY,CAAZ,CAAH;EACN;;EAED;IACMtC,MAAE,gBADR;IAEUmC,QAFV;IAGMI,MAAEF,QAHR;IAIOnB,KAJP;IAKMsB,MAAE,KALR;IAMK1C,KAAEK,QAAQ,CAACL,GAAG,IAAI,IAAR;EANf;AAQD;;AAED,SAAS2C,YAAT,CACEzC,IADF,EAEEe,KAFF,EAGEjB,GAHF,EAG0B;EAExB;IACME,IADN;IAEOe,KAFP;IAGUoB,UAAEpB,KAHZ;IAIKjB,KAAEK,QAAQ,CAACL,GAAG,IAAI,IAAR;EAJf;AAMD,C,CAED;;;AAEA,SAASG,SAAT,CAAmByC,KAAnB,EAA2C5C,GAA3C,EAAmE;EACjE;IACME,MAAE,MADR;IAEO0C,OAAEA,KAAK,IAAI,EAFlB;IAGK5C,KAAEK,QAAQ,CAACL,GAAG,IAAI,IAAR;EAHf;AAKD;;AAED,SAAS6C,SAAT,CAAmBC,GAAnB,EAAgC7B,KAAhC,EAAuDjB,GAAvD,EAA+E;EAC7E;IACME,MAAE,UADR;IAEK4C,KAAEA,GAFP;IAGO7B,KAHP;IAIKjB,KAAEK,QAAQ,CAACL,GAAG,IAAI,IAAR;EAJf;AAMD;;AAED,SAAS+C,YAAT,CACEC,IADF,EAEErB,WAFF,EAGE3B,GAHF,EAG0B;EAExB;IACME,MAAE,SADR;IAEM8C,MAAEA,IAAI,IAAI,EAFhB;IAGarB,aAAEA,WAAW,IAAI,EAH9B;IAIK3B,KAAEK,QAAQ,CAACL,GAAG,IAAI,IAAR;EAJf;AAMD;;AAED,SAASiD,WAAT,CAAqBC,MAArB,EAAoC;EAClC,OAAOA,MAAM,IAAI,IAAjB;AACD;;AAED,SAASC,aAAT,CAAuBC,IAAvB,EAAqCC,MAArC,EAAmD;EACjD;IACMD,IADN;IAIFC;EAJE;AAID;;AAED,OAAM,MAAOC,SAAS;EACdJ,QAAE,aADY;EAEfK,OAAE;IAAEH,IAAI,EAAE,CAAR;IAAWC,MAAM,EAAE;EAAnB,CAFa;EAGjBG,KAAE;IAAEJ,IAAI,EAAE,CAAR;IAAWC,MAAM,EAAE;EAAnB;AAHe,CAAhB;;AAeN,SAAShD,QAAT,GAAgC;EAAA,kCAAXoD,IAAW;IAAXA,IAAW;EAAA;;EAC9B,IAAIA,IAAI,CAACC,MAAL,KAAgB,CAApB,EAAuB;IACrB,IAAI1D,GAAG,GAAGyD,IAAI,CAAC,CAAD,CAAd;;IAEA,IAAIzD,GAAG,IAAI,OAAOA,GAAP,KAAe,QAA1B,EAAoC;MAClC;QACQkD,QAAED,WAAW,CAACjD,GAAG,CAACkD,MAAL,CADrB;QAEOK,OAAEJ,aAAa,CAACnD,GAAG,CAACuD,KAAJ,CAAUH,IAAX,EAAiBpD,GAAG,CAACuD,KAAJ,CAAUF,MAA3B,CAFtB;QAGKG,KAAEL,aAAa,CAACnD,GAAG,CAACwD,GAAJ,CAAQJ,IAAT,EAAepD,GAAG,CAACwD,GAAJ,CAAQH,MAAvB;MAHpB;IAKD,CAND,MAMO;MACL,OAAOC,SAAP;IACD;EACF,CAZD,MAYO;IACL,IAAI,CAACK,SAAD,EAAYC,WAAZ,EAAyBC,OAAzB,EAAkCC,SAAlC,EAA6CZ,MAA7C,IAAuDO,IAA3D;IACA;MACQP,QAAED,WAAW,CAACC,MAAD,CADrB;MAEOK,OAAEJ,aAAa,CAACQ,SAAD,EAAYC,WAAZ,CAFtB;MAGKJ,KAAEL,aAAa,CAACU,OAAD,EAAUC,SAAV;IAHpB;EAMJ;AAAC;;AAED,SAAShC,YAAT,CAAsBiC,GAAtB,EAAoE;EAClE,OAAOA,GAAG,CAAC,CAAD,CAAH,KAAW,QAAlB;AACD;;AAED,SAAShC,KAAT,CACEiC,IADF,EACkF;EAEhF,OAAO,CAACpC,KAAK,CAACC,OAAN,CAAcmC,IAAd,CAAR;AACD;;AAED;EACUC,UAAEtE,aADZ;EAEOuE,OAAE5D,UAFT;EAGS6D,SAAEzD,YAHX;EAIS0D,SAAEpD,YAJX;EAKiBqD,iBAAEnD,oBALnB;EAMSoD,SAAEjD,YANX;EAOiBkD,iBAAE9D,oBAPnB;EAQM+D,MAAEvC,SARR;EASMwC,MAAEvC,SATR;EAUOwC,OAAEtC,UAVT;EAWMxC,MAAEK,SAXR;EAYQ0E,QAAExD,WAZV;EAaMrB,MAAEK,SAbR;EAcMyE,MAAE/B,SAdR;EAeSgC,SAAElC,YAfX;EAgBSpC,SAAEwC,YAhBX;EAiBK/C,KAAEK,QAjBP;EAkBKyE,KAAE3B,aAlBP;EAoBQ4B,QAAEF,OAAO,CAAC,eAAD,CApBjB;EAqBSG,SAAEH,OAAO,CAAC,gBAAD,CArBlB;EAsBQI,QAAEJ,OAAO,CAAC,eAAD,CAtBjB;;EAuBWK;IACP,OAAOvC,YAAY,CAAC,kBAAD,EAAqBuC,SAArB,CAAnB;EACD,CAzBH;;EA0BMC;IACF,OAAOxC,YAAY,CAAC,aAAD,EAAgB,IAAhB,CAAnB;EAEF;;AA7BF;;AA+BA,SAASkC,OAAT,CAAwC3E,IAAxC,EAAuD;EACrD,OAAO,UAASe,KAAT,EAA0B;IAC/B,OAAO0B,YAAY,CAACzC,IAAD,EAAOe,KAAP,CAAnB;EAEJ,CAHE;AAGD","names":["buildMustache","path","params","hash","raw","loc","buildPath","type","buildHash","escaped","buildLoc","buildBlock","program","inverse","buildElementModifier","buildPartial","name","indent","strip","open","close","buildComment","value","buildMustacheComment","buildConcat","parts","buildElement","tag","attributes","modifiers","children","comments","blockParams","Array","isArray","isBlockParms","isLoc","selfClosing","buildAttr","buildText","chars","buildSexpr","original","split","thisHead","slice","this","data","buildLiteral","pairs","buildPair","key","buildProgram","body","buildSource","source","buildPosition","line","column","SYNTHETIC","start","end","args","length","startLine","startColumn","endLine","endColumn","arr","item","mustache","block","partial","comment","mustacheComment","element","elementModifier","attr","text","sexpr","concat","pair","literal","pos","string","boolean","number","undefined","null"],"sourceRoot":"","sources":["../../../../packages/@glimmer/syntax/lib/builders.ts"],"sourcesContent":["import * as AST from './types/nodes';\nimport { Option } from '@glimmer/interfaces';\n\n// Statements\n\nexport type BuilderPath = string | AST.PathExpression;\nexport type TagDescriptor = string | { name: string; selfClosing: boolean };\n\nfunction buildMustache(\n  path: BuilderPath | AST.Literal,\n  params?: AST.Expression[],\n  hash?: AST.Hash,\n  raw?: boolean,\n  loc?: AST.SourceLocation\n): AST.MustacheStatement {\n  if (typeof path === 'string') {\n    path = buildPath(path);\n  }\n\n  return {\n    type: 'MustacheStatement',\n    path,\n    params: params || [],\n    hash: hash || buildHash([]),\n    escaped: !raw,\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildBlock(\n  path: BuilderPath,\n  params: Option<AST.Expression[]>,\n  hash: Option<AST.Hash>,\n  program: AST.Program,\n  inverse?: Option<AST.Program>,\n  loc?: AST.SourceLocation\n): AST.BlockStatement {\n  return {\n    type: 'BlockStatement',\n    path: buildPath(path),\n    params: params || [],\n    hash: hash || buildHash([]),\n    program: program || null,\n    inverse: inverse || null,\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildElementModifier(\n  path: BuilderPath,\n  params?: AST.Expression[],\n  hash?: AST.Hash,\n  loc?: Option<AST.SourceLocation>\n): AST.ElementModifierStatement {\n  return {\n    type: 'ElementModifierStatement',\n    path: buildPath(path),\n    params: params || [],\n    hash: hash || buildHash([]),\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildPartial(\n  name: AST.PathExpression,\n  params?: AST.Expression[],\n  hash?: AST.Hash,\n  indent?: string,\n  loc?: AST.SourceLocation\n): AST.PartialStatement {\n  return {\n    type: 'PartialStatement',\n    name: name,\n    params: params || [],\n    hash: hash || buildHash([]),\n    indent: indent || '',\n    strip: { open: false, close: false },\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildComment(value: string, loc?: AST.SourceLocation): AST.CommentStatement {\n  return {\n    type: 'CommentStatement',\n    value: value,\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildMustacheComment(\n  value: string,\n  loc?: AST.SourceLocation\n): AST.MustacheCommentStatement {\n  return {\n    type: 'MustacheCommentStatement',\n    value: value,\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildConcat(\n  parts: (AST.TextNode | AST.MustacheStatement)[],\n  loc?: AST.SourceLocation\n): AST.ConcatStatement {\n  return {\n    type: 'ConcatStatement',\n    parts: parts || [],\n    loc: buildLoc(loc || null),\n  };\n}\n\n// Nodes\n\nfunction buildElement(\n  tag: TagDescriptor,\n  attributes?: AST.AttrNode[],\n  modifiers?: AST.ElementModifierStatement[],\n  children?: AST.Statement[],\n  loc?: AST.SourceLocation\n): AST.ElementNode;\nfunction buildElement(\n  tag: TagDescriptor,\n  attributes?: AST.AttrNode[],\n  modifiers?: AST.ElementModifierStatement[],\n  children?: AST.Statement[],\n  comments?: AST.MustacheCommentStatement[],\n  blockParams?: string[],\n  loc?: AST.SourceLocation\n): AST.ElementNode;\n\nfunction buildElement(\n  tag: TagDescriptor,\n  attributes?: AST.AttrNode[],\n  modifiers?: AST.ElementModifierStatement[],\n  children?: AST.Statement[],\n  comments?: AST.MustacheCommentStatement[] | AST.SourceLocation | string[],\n  blockParams?: string[],\n  loc?: AST.SourceLocation\n): AST.ElementNode {\n  // this is used for backwards compat prior to `blockParams` being added to the AST\n  if (Array.isArray(comments)) {\n    if (isBlockParms(comments)) {\n      blockParams = comments;\n      comments = [];\n    } else if (isLoc(blockParams)) {\n      loc = blockParams;\n      blockParams = [];\n    }\n  } else if (isLoc(comments)) {\n    // this is used for backwards compat prior to `comments` being added to the AST\n    loc = comments;\n    comments = [];\n  } else if (isLoc(blockParams)) {\n    loc = blockParams;\n    blockParams = [];\n  }\n\n  // this is used for backwards compat, prior to `selfClosing` being part of the ElementNode AST\n  let selfClosing = false;\n  if (typeof tag === 'object') {\n    selfClosing = tag.selfClosing;\n    tag = tag.name;\n  }\n\n  return {\n    type: 'ElementNode',\n    tag: tag || '',\n    selfClosing: selfClosing,\n    attributes: attributes || [],\n    blockParams: blockParams || [],\n    modifiers: modifiers || [],\n    comments: (comments as AST.MustacheCommentStatement[]) || [],\n    children: children || [],\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildAttr(\n  name: string,\n  value: AST.AttrNode['value'],\n  loc?: AST.SourceLocation\n): AST.AttrNode {\n  return {\n    type: 'AttrNode',\n    name: name,\n    value: value,\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildText(chars?: string, loc?: AST.SourceLocation): AST.TextNode {\n  return {\n    type: 'TextNode',\n    chars: chars || '',\n    loc: buildLoc(loc || null),\n  };\n}\n\n// Expressions\n\nfunction buildSexpr(\n  path: BuilderPath,\n  params?: AST.Expression[],\n  hash?: AST.Hash,\n  loc?: AST.SourceLocation\n): AST.SubExpression {\n  return {\n    type: 'SubExpression',\n    path: buildPath(path),\n    params: params || [],\n    hash: hash || buildHash([]),\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildPath(original: BuilderPath, loc?: AST.SourceLocation): AST.PathExpression {\n  if (typeof original !== 'string') return original;\n\n  let parts = original.split('.');\n  let thisHead = false;\n\n  if (parts[0] === 'this') {\n    thisHead = true;\n    parts = parts.slice(1);\n  }\n\n  return {\n    type: 'PathExpression',\n    original,\n    this: thisHead,\n    parts,\n    data: false,\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildLiteral<T extends AST.Literal>(\n  type: T['type'],\n  value: T['value'],\n  loc?: AST.SourceLocation\n): AST.Literal {\n  return {\n    type,\n    value,\n    original: value,\n    loc: buildLoc(loc || null),\n  } as AST.Literal;\n}\n\n// Miscellaneous\n\nfunction buildHash(pairs?: AST.HashPair[], loc?: AST.SourceLocation): AST.Hash {\n  return {\n    type: 'Hash',\n    pairs: pairs || [],\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildPair(key: string, value: AST.Expression, loc?: AST.SourceLocation): AST.HashPair {\n  return {\n    type: 'HashPair',\n    key: key,\n    value,\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildProgram(\n  body?: AST.Statement[],\n  blockParams?: string[],\n  loc?: AST.SourceLocation\n): AST.Program {\n  return {\n    type: 'Program',\n    body: body || [],\n    blockParams: blockParams || [],\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildSource(source?: string) {\n  return source || null;\n}\n\nfunction buildPosition(line: number, column: number) {\n  return {\n    line,\n    column,\n  };\n}\n\nexport const SYNTHETIC: AST.SourceLocation = {\n  source: '(synthetic)',\n  start: { line: 1, column: 0 },\n  end: { line: 1, column: 0 },\n};\n\nfunction buildLoc(loc: Option<AST.SourceLocation>): AST.SourceLocation;\nfunction buildLoc(\n  startLine: number,\n  startColumn: number,\n  endLine?: number,\n  endColumn?: number,\n  source?: string\n): AST.SourceLocation;\n\nfunction buildLoc(...args: any[]): AST.SourceLocation {\n  if (args.length === 1) {\n    let loc = args[0];\n\n    if (loc && typeof loc === 'object') {\n      return {\n        source: buildSource(loc.source),\n        start: buildPosition(loc.start.line, loc.start.column),\n        end: buildPosition(loc.end.line, loc.end.column),\n      };\n    } else {\n      return SYNTHETIC;\n    }\n  } else {\n    let [startLine, startColumn, endLine, endColumn, source] = args;\n    return {\n      source: buildSource(source),\n      start: buildPosition(startLine, startColumn),\n      end: buildPosition(endLine, endColumn),\n    };\n  }\n}\n\nfunction isBlockParms(arr: string[] | AST.MustacheCommentStatement[]): arr is string[] {\n  return arr[0] === 'string';\n}\n\nfunction isLoc(\n  item: string[] | AST.SourceLocation | AST.MustacheCommentStatement[] | undefined\n): item is AST.SourceLocation {\n  return !Array.isArray(item);\n}\n\nexport default {\n  mustache: buildMustache,\n  block: buildBlock,\n  partial: buildPartial,\n  comment: buildComment,\n  mustacheComment: buildMustacheComment,\n  element: buildElement,\n  elementModifier: buildElementModifier,\n  attr: buildAttr,\n  text: buildText,\n  sexpr: buildSexpr,\n  path: buildPath,\n  concat: buildConcat,\n  hash: buildHash,\n  pair: buildPair,\n  literal: buildLiteral,\n  program: buildProgram,\n  loc: buildLoc,\n  pos: buildPosition,\n\n  string: literal('StringLiteral'),\n  boolean: literal('BooleanLiteral'),\n  number: literal('NumberLiteral'),\n  undefined() {\n    return buildLiteral('UndefinedLiteral', undefined);\n  },\n  null() {\n    return buildLiteral('NullLiteral', null);\n  },\n};\n\nfunction literal<T extends AST.Literal>(type: T['type']) {\n  return function(value: T['value']) {\n    return buildLiteral(type, value);\n  };\n}\n"]},"metadata":{},"sourceType":"module"}