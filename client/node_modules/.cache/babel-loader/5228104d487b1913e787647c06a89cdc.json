{"ast":null,"code":"import b from '../builders';\nimport { appendChild, isLiteral, printLiteral } from '../utils';\nimport { Parser } from '../parser';\nimport SyntaxError from '../errors/syntax-error';\nexport class HandlebarsNodeVisitors extends Parser {\n  constructor() {\n    super(...arguments);\n    this.cursorCount = 0;\n  }\n\n  cursor() {\n    return `%cursor:${this.cursorCount++}%`;\n  }\n\n  Program(program) {\n    let body = [];\n    this.cursorCount = 0;\n    let node = b.program(body, program.blockParams, program.loc);\n    let i,\n        l = program.body.length;\n    this.elementStack.push(node);\n\n    if (l === 0) {\n      return this.elementStack.pop();\n    }\n\n    for (i = 0; i < l; i++) {\n      this.acceptNode(program.body[i]);\n    } // Ensure that that the element stack is balanced properly.\n\n\n    let poppedNode = this.elementStack.pop();\n\n    if (poppedNode !== node) {\n      let elementNode = poppedNode;\n      throw new SyntaxError('Unclosed element `' + elementNode.tag + '` (on line ' + elementNode.loc.start.line + ').', elementNode.loc);\n    }\n\n    return node;\n  }\n\n  BlockStatement(block) {\n    if (this.tokenizer['state'] === 'comment') {\n      this.appendToCommentData(this.sourceForNode(block));\n      return;\n    }\n\n    if (this.tokenizer['state'] !== 'comment' && this.tokenizer['state'] !== 'data' && this.tokenizer['state'] !== 'beforeData') {\n      throw new SyntaxError('A block may only be used inside an HTML element or another block.', block.loc);\n    }\n\n    let {\n      path,\n      params,\n      hash\n    } = acceptCallNodes(this, block);\n    let program = this.Program(block.program);\n    let inverse = block.inverse ? this.Program(block.inverse) : null;\n\n    if (path.original === 'in-element') {\n      hash = addInElementHash(this.cursor(), hash, block.loc);\n    }\n\n    let node = b.block(path, params, hash, program, inverse, block.loc);\n    let parentProgram = this.currentElement();\n    appendChild(parentProgram, node);\n  }\n\n  MustacheStatement(rawMustache) {\n    let {\n      tokenizer\n    } = this;\n\n    if (tokenizer.state === 'comment') {\n      this.appendToCommentData(this.sourceForNode(rawMustache));\n      return;\n    }\n\n    let mustache;\n    let {\n      escaped,\n      loc\n    } = rawMustache;\n\n    if (rawMustache.path.type.match(/Literal$/)) {\n      mustache = {\n        type: 'MustacheStatement',\n        path: this.acceptNode(rawMustache.path),\n        params: [],\n        hash: b.hash(),\n        escaped,\n        loc\n      };\n    } else {\n      let {\n        path,\n        params,\n        hash\n      } = acceptCallNodes(this, rawMustache);\n      mustache = b.mustache(path, params, hash, !escaped, loc);\n    }\n\n    switch (tokenizer.state) {\n      // Tag helpers\n      case \"tagOpen\"\n      /* tagOpen */\n      :\n      case \"tagName\"\n      /* tagName */\n      :\n        throw new SyntaxError(`Cannot use mustaches in an elements tagname: \\`${this.sourceForNode(rawMustache, rawMustache.path)}\\` at L${loc.start.line}:C${loc.start.column}`, mustache.loc);\n\n      case \"beforeAttributeName\"\n      /* beforeAttributeName */\n      :\n        addElementModifier(this.currentStartTag, mustache);\n        break;\n\n      case \"attributeName\"\n      /* attributeName */\n      :\n      case \"afterAttributeName\"\n      /* afterAttributeName */\n      :\n        this.beginAttributeValue(false);\n        this.finishAttributeValue();\n        addElementModifier(this.currentStartTag, mustache);\n        tokenizer.transitionTo(\"beforeAttributeName\"\n        /* beforeAttributeName */\n        );\n        break;\n\n      case \"afterAttributeValueQuoted\"\n      /* afterAttributeValueQuoted */\n      :\n        addElementModifier(this.currentStartTag, mustache);\n        tokenizer.transitionTo(\"beforeAttributeName\"\n        /* beforeAttributeName */\n        );\n        break;\n      // Attribute values\n\n      case \"beforeAttributeValue\"\n      /* beforeAttributeValue */\n      :\n        this.beginAttributeValue(false);\n        appendDynamicAttributeValuePart(this.currentAttribute, mustache);\n        tokenizer.transitionTo(\"attributeValueUnquoted\"\n        /* attributeValueUnquoted */\n        );\n        break;\n\n      case \"attributeValueDoubleQuoted\"\n      /* attributeValueDoubleQuoted */\n      :\n      case \"attributeValueSingleQuoted\"\n      /* attributeValueSingleQuoted */\n      :\n      case \"attributeValueUnquoted\"\n      /* attributeValueUnquoted */\n      :\n        appendDynamicAttributeValuePart(this.currentAttribute, mustache);\n        break;\n      // TODO: Only append child when the tokenizer state makes\n      // sense to do so, otherwise throw an error.\n\n      default:\n        appendChild(this.currentElement(), mustache);\n    }\n\n    return mustache;\n  }\n\n  ContentStatement(content) {\n    updateTokenizerLocation(this.tokenizer, content);\n    this.tokenizer.tokenizePart(content.value);\n    this.tokenizer.flushData();\n  }\n\n  CommentStatement(rawComment) {\n    let {\n      tokenizer\n    } = this;\n\n    if (tokenizer.state === \"comment\"\n    /* comment */\n    ) {\n      this.appendToCommentData(this.sourceForNode(rawComment));\n      return null;\n    }\n\n    let {\n      value,\n      loc\n    } = rawComment;\n    let comment = b.mustacheComment(value, loc);\n\n    switch (tokenizer.state) {\n      case \"beforeAttributeName\"\n      /* beforeAttributeName */\n      :\n        this.currentStartTag.comments.push(comment);\n        break;\n\n      case \"beforeData\"\n      /* beforeData */\n      :\n      case \"data\"\n      /* data */\n      :\n        appendChild(this.currentElement(), comment);\n        break;\n\n      default:\n        throw new SyntaxError(`Using a Handlebars comment when in the \\`${tokenizer['state']}\\` state is not supported: \"${comment.value}\" on line ${loc.start.line}:${loc.start.column}`, rawComment.loc);\n    }\n\n    return comment;\n  }\n\n  PartialStatement(partial) {\n    let {\n      loc\n    } = partial;\n    throw new SyntaxError(`Handlebars partials are not supported: \"${this.sourceForNode(partial, partial.name)}\" at L${loc.start.line}:C${loc.start.column}`, partial.loc);\n  }\n\n  PartialBlockStatement(partialBlock) {\n    let {\n      loc\n    } = partialBlock;\n    throw new SyntaxError(`Handlebars partial blocks are not supported: \"${this.sourceForNode(partialBlock, partialBlock.name)}\" at L${loc.start.line}:C${loc.start.column}`, partialBlock.loc);\n  }\n\n  Decorator(decorator) {\n    let {\n      loc\n    } = decorator;\n    throw new SyntaxError(`Handlebars decorators are not supported: \"${this.sourceForNode(decorator, decorator.path)}\" at L${loc.start.line}:C${loc.start.column}`, decorator.loc);\n  }\n\n  DecoratorBlock(decoratorBlock) {\n    let {\n      loc\n    } = decoratorBlock;\n    throw new SyntaxError(`Handlebars decorator blocks are not supported: \"${this.sourceForNode(decoratorBlock, decoratorBlock.path)}\" at L${loc.start.line}:C${loc.start.column}`, decoratorBlock.loc);\n  }\n\n  SubExpression(sexpr) {\n    let {\n      path,\n      params,\n      hash\n    } = acceptCallNodes(this, sexpr);\n    return b.sexpr(path, params, hash, sexpr.loc);\n  }\n\n  PathExpression(path) {\n    let {\n      original,\n      loc\n    } = path;\n    let parts;\n\n    if (original.indexOf('/') !== -1) {\n      if (original.slice(0, 2) === './') {\n        throw new SyntaxError(`Using \"./\" is not supported in Glimmer and unnecessary: \"${path.original}\" on line ${loc.start.line}.`, path.loc);\n      }\n\n      if (original.slice(0, 3) === '../') {\n        throw new SyntaxError(`Changing context using \"../\" is not supported in Glimmer: \"${path.original}\" on line ${loc.start.line}.`, path.loc);\n      }\n\n      if (original.indexOf('.') !== -1) {\n        throw new SyntaxError(`Mixing '.' and '/' in paths is not supported in Glimmer; use only '.' to separate property paths: \"${path.original}\" on line ${loc.start.line}.`, path.loc);\n      }\n\n      parts = [path.parts.join('/')];\n    } else if (original === '.') {\n      let locationInfo = `L${loc.start.line}:C${loc.start.column}`;\n      throw new SyntaxError(`'.' is not a supported path in Glimmer; check for a path with a trailing '.' at ${locationInfo}.`, path.loc);\n    } else {\n      parts = path.parts;\n    }\n\n    let thisHead = false; // This is to fix a bug in the Handlebars AST where the path expressions in\n    // `{{this.foo}}` (and similarly `{{foo-bar this.foo named=this.foo}}` etc)\n    // are simply turned into `{{foo}}`. The fix is to push it back onto the\n    // parts array and let the runtime see the difference. However, we cannot\n    // simply use the string `this` as it means literally the property called\n    // \"this\" in the current context (it can be expressed in the syntax as\n    // `{{[this]}}`, where the square bracket are generally for this kind of\n    // escaping – such as `{{foo.[\"bar.baz\"]}}` would mean lookup a property\n    // named literally \"bar.baz\" on `this.foo`). By convention, we use `null`\n    // for this purpose.\n\n    if (original.match(/^this(\\..+)?$/)) {\n      thisHead = true;\n    }\n\n    return {\n      type: 'PathExpression',\n      original: path.original,\n      this: thisHead,\n      parts,\n      data: path.data,\n      loc: path.loc\n    };\n  }\n\n  Hash(hash) {\n    let pairs = [];\n\n    for (let i = 0; i < hash.pairs.length; i++) {\n      let pair = hash.pairs[i];\n      pairs.push(b.pair(pair.key, this.acceptNode(pair.value), pair.loc));\n    }\n\n    return b.hash(pairs, hash.loc);\n  }\n\n  StringLiteral(string) {\n    return b.literal('StringLiteral', string.value, string.loc);\n  }\n\n  BooleanLiteral(boolean) {\n    return b.literal('BooleanLiteral', boolean.value, boolean.loc);\n  }\n\n  NumberLiteral(number) {\n    return b.literal('NumberLiteral', number.value, number.loc);\n  }\n\n  UndefinedLiteral(undef) {\n    return b.literal('UndefinedLiteral', undefined, undef.loc);\n  }\n\n  NullLiteral(nul) {\n    return b.literal('NullLiteral', null, nul.loc);\n  }\n\n}\n\nfunction calculateRightStrippedOffsets(original, value) {\n  if (value === '') {\n    // if it is empty, just return the count of newlines\n    // in original\n    return {\n      lines: original.split('\\n').length - 1,\n      columns: 0\n    };\n  } // otherwise, return the number of newlines prior to\n  // `value`\n\n\n  let difference = original.split(value)[0];\n  let lines = difference.split(/\\n/);\n  let lineCount = lines.length - 1;\n  return {\n    lines: lineCount,\n    columns: lines[lineCount].length\n  };\n}\n\nfunction updateTokenizerLocation(tokenizer, content) {\n  let line = content.loc.start.line;\n  let column = content.loc.start.column;\n  let offsets = calculateRightStrippedOffsets(content.original, content.value);\n  line = line + offsets.lines;\n\n  if (offsets.lines) {\n    column = offsets.columns;\n  } else {\n    column = column + offsets.columns;\n  }\n\n  tokenizer.line = line;\n  tokenizer.column = column;\n}\n\nfunction acceptCallNodes(compiler, node) {\n  let path = compiler.PathExpression(node.path);\n  let params = node.params ? node.params.map(e => compiler.acceptNode(e)) : [];\n  let hash = node.hash ? compiler.Hash(node.hash) : b.hash();\n  return {\n    path,\n    params,\n    hash\n  };\n}\n\nfunction addElementModifier(element, mustache) {\n  let {\n    path,\n    params,\n    hash,\n    loc\n  } = mustache;\n\n  if (isLiteral(path)) {\n    let modifier = `{{${printLiteral(path)}}}`;\n    let tag = `<${element.name} ... ${modifier} ...`;\n    throw new SyntaxError(`In ${tag}, ${modifier} is not a valid modifier: \"${path.original}\" on line ${loc && loc.start.line}.`, mustache.loc);\n  }\n\n  let modifier = b.elementModifier(path, params, hash, loc);\n  element.modifiers.push(modifier);\n}\n\nfunction addInElementHash(cursor, hash, loc) {\n  let hasNextSibling = false;\n  hash.pairs.forEach(pair => {\n    if (pair.key === 'guid') {\n      throw new SyntaxError('Cannot pass `guid` from user space', loc);\n    }\n\n    if (pair.key === 'nextSibling') {\n      hasNextSibling = true;\n    }\n  });\n  let guid = b.literal('StringLiteral', cursor);\n  let guidPair = b.pair('guid', guid);\n  hash.pairs.unshift(guidPair);\n\n  if (!hasNextSibling) {\n    let nullLiteral = b.literal('NullLiteral', null);\n    let nextSibling = b.pair('nextSibling', nullLiteral);\n    hash.pairs.push(nextSibling);\n  }\n\n  return hash;\n}\n\nfunction appendDynamicAttributeValuePart(attribute, part) {\n  attribute.isDynamic = true;\n  attribute.parts.push(part);\n}","map":{"version":3,"mappings":"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","names":["b","appendChild","isLiteral","printLiteral","Parser","SyntaxError","HandlebarsNodeVisitors","constructor","cursorCount","cursor","Program","program","body","node","blockParams","loc","i","l","length","elementStack","push","pop","acceptNode","poppedNode","elementNode","tag","start","line","BlockStatement","block","tokenizer","appendToCommentData","sourceForNode","path","params","hash","acceptCallNodes","inverse","original","addInElementHash","parentProgram","currentElement","MustacheStatement","rawMustache","state","mustache","escaped","type","match","column","addElementModifier","currentStartTag","beginAttributeValue","finishAttributeValue","transitionTo","appendDynamicAttributeValuePart","currentAttribute","ContentStatement","content","updateTokenizerLocation","tokenizePart","value","flushData","CommentStatement","rawComment","comment","mustacheComment","comments","PartialStatement","partial","name","PartialBlockStatement","partialBlock","Decorator","decorator","DecoratorBlock","decoratorBlock","SubExpression","sexpr","PathExpression","parts","indexOf","slice","join","locationInfo","thisHead","this","data","Hash","pairs","pair","key","StringLiteral","string","literal","BooleanLiteral","boolean","NumberLiteral","number","UndefinedLiteral","undef","undefined","NullLiteral","nul","calculateRightStrippedOffsets","lines","split","columns","difference","lineCount","offsets","compiler","map","e","element","modifier","elementModifier","modifiers","hasNextSibling","forEach","guid","guidPair","unshift","nullLiteral","nextSibling","attribute","part","isDynamic"],"sourceRoot":"","sources":["../../../../../packages/@glimmer/syntax/lib/parser/handlebars-node-visitors.ts"],"sourcesContent":["import b from '../builders';\nimport { appendChild, isLiteral, printLiteral } from '../utils';\nimport * as AST from '../types/nodes';\nimport * as HandlebarsAST from '../types/handlebars-ast';\nimport { Parser, Tag, Attribute } from '../parser';\nimport SyntaxError from '../errors/syntax-error';\nimport { Option } from '@glimmer/util';\nimport { Recast } from '@glimmer/interfaces';\nimport { TokenizerState } from 'simple-html-tokenizer';\n\nexport abstract class HandlebarsNodeVisitors extends Parser {\n  abstract appendToCommentData(s: string): void;\n  abstract beginAttributeValue(quoted: boolean): void;\n  abstract finishAttributeValue(): void;\n\n  cursorCount = 0;\n\n  cursor() {\n    return `%cursor:${this.cursorCount++}%`;\n  }\n\n  Program(program: HandlebarsAST.Program): AST.Program {\n    let body: AST.Statement[] = [];\n    this.cursorCount = 0;\n    let node = b.program(body, program.blockParams, program.loc);\n    let i,\n      l = program.body.length;\n\n    this.elementStack.push(node);\n\n    if (l === 0) {\n      return this.elementStack.pop() as AST.Program;\n    }\n\n    for (i = 0; i < l; i++) {\n      this.acceptNode(program.body[i]);\n    }\n\n    // Ensure that that the element stack is balanced properly.\n    let poppedNode = this.elementStack.pop();\n    if (poppedNode !== node) {\n      let elementNode = poppedNode as AST.ElementNode;\n\n      throw new SyntaxError(\n        'Unclosed element `' + elementNode.tag + '` (on line ' + elementNode.loc!.start.line + ').',\n        elementNode.loc\n      );\n    }\n\n    return node;\n  }\n\n  BlockStatement(block: HandlebarsAST.BlockStatement) {\n    if (this.tokenizer['state'] === 'comment') {\n      this.appendToCommentData(this.sourceForNode(block));\n      return;\n    }\n\n    if (\n      this.tokenizer['state'] !== 'comment' &&\n      this.tokenizer['state'] !== 'data' &&\n      this.tokenizer['state'] !== 'beforeData'\n    ) {\n      throw new SyntaxError(\n        'A block may only be used inside an HTML element or another block.',\n        block.loc\n      );\n    }\n\n    let { path, params, hash } = acceptCallNodes(this, block);\n    let program = this.Program(block.program);\n    let inverse = block.inverse ? this.Program(block.inverse) : null;\n\n    if (path.original === 'in-element') {\n      hash = addInElementHash(this.cursor(), hash, block.loc);\n    }\n\n    let node = b.block(path, params, hash, program, inverse, block.loc);\n\n    let parentProgram = this.currentElement();\n    appendChild(parentProgram, node);\n  }\n\n  MustacheStatement(rawMustache: HandlebarsAST.MustacheStatement) {\n    let { tokenizer } = this;\n\n    if (tokenizer.state === 'comment') {\n      this.appendToCommentData(this.sourceForNode(rawMustache));\n      return;\n    }\n\n    let mustache: AST.MustacheStatement;\n    let { escaped, loc } = rawMustache;\n\n    if (rawMustache.path.type.match(/Literal$/)) {\n      mustache = {\n        type: 'MustacheStatement',\n        path: this.acceptNode<AST.Literal>(rawMustache.path),\n        params: [],\n        hash: b.hash(),\n        escaped,\n        loc,\n      };\n    } else {\n      let { path, params, hash } = acceptCallNodes(\n        this,\n        rawMustache as HandlebarsAST.MustacheStatement & {\n          path: HandlebarsAST.PathExpression;\n        }\n      );\n      mustache = b.mustache(path, params, hash, !escaped, loc);\n    }\n\n    switch (tokenizer.state) {\n      // Tag helpers\n      case TokenizerState.tagOpen:\n      case TokenizerState.tagName:\n        throw new SyntaxError(\n          `Cannot use mustaches in an elements tagname: \\`${this.sourceForNode(\n            rawMustache,\n            rawMustache.path\n          )}\\` at L${loc.start.line}:C${loc.start.column}`,\n          mustache.loc\n        );\n\n      case TokenizerState.beforeAttributeName:\n        addElementModifier(this.currentStartTag, mustache);\n        break;\n      case TokenizerState.attributeName:\n      case TokenizerState.afterAttributeName:\n        this.beginAttributeValue(false);\n        this.finishAttributeValue();\n        addElementModifier(this.currentStartTag, mustache);\n        tokenizer.transitionTo(TokenizerState.beforeAttributeName);\n        break;\n      case TokenizerState.afterAttributeValueQuoted:\n        addElementModifier(this.currentStartTag, mustache);\n        tokenizer.transitionTo(TokenizerState.beforeAttributeName);\n        break;\n\n      // Attribute values\n      case TokenizerState.beforeAttributeValue:\n        this.beginAttributeValue(false);\n        appendDynamicAttributeValuePart(this.currentAttribute!, mustache);\n        tokenizer.transitionTo(TokenizerState.attributeValueUnquoted);\n        break;\n      case TokenizerState.attributeValueDoubleQuoted:\n      case TokenizerState.attributeValueSingleQuoted:\n      case TokenizerState.attributeValueUnquoted:\n        appendDynamicAttributeValuePart(this.currentAttribute!, mustache);\n        break;\n\n      // TODO: Only append child when the tokenizer state makes\n      // sense to do so, otherwise throw an error.\n      default:\n        appendChild(this.currentElement(), mustache);\n    }\n\n    return mustache;\n  }\n\n  ContentStatement(content: HandlebarsAST.ContentStatement) {\n    updateTokenizerLocation(this.tokenizer, content);\n\n    this.tokenizer.tokenizePart(content.value);\n    this.tokenizer.flushData();\n  }\n\n  CommentStatement(\n    rawComment: HandlebarsAST.CommentStatement\n  ): Option<AST.MustacheCommentStatement> {\n    let { tokenizer } = this;\n\n    if (tokenizer.state === TokenizerState.comment) {\n      this.appendToCommentData(this.sourceForNode(rawComment));\n      return null;\n    }\n\n    let { value, loc } = rawComment;\n    let comment = b.mustacheComment(value, loc);\n\n    switch (tokenizer.state) {\n      case TokenizerState.beforeAttributeName:\n        this.currentStartTag.comments.push(comment);\n        break;\n\n      case TokenizerState.beforeData:\n      case TokenizerState.data:\n        appendChild(this.currentElement(), comment);\n        break;\n\n      default:\n        throw new SyntaxError(\n          `Using a Handlebars comment when in the \\`${\n            tokenizer['state']\n          }\\` state is not supported: \"${comment.value}\" on line ${loc.start.line}:${\n            loc.start.column\n          }`,\n          rawComment.loc\n        );\n    }\n\n    return comment;\n  }\n\n  PartialStatement(partial: HandlebarsAST.PartialStatement) {\n    let { loc } = partial;\n\n    throw new SyntaxError(\n      `Handlebars partials are not supported: \"${this.sourceForNode(partial, partial.name)}\" at L${\n        loc.start.line\n      }:C${loc.start.column}`,\n      partial.loc\n    );\n  }\n\n  PartialBlockStatement(partialBlock: HandlebarsAST.PartialBlockStatement) {\n    let { loc } = partialBlock;\n\n    throw new SyntaxError(\n      `Handlebars partial blocks are not supported: \"${this.sourceForNode(\n        partialBlock,\n        partialBlock.name\n      )}\" at L${loc.start.line}:C${loc.start.column}`,\n      partialBlock.loc\n    );\n  }\n\n  Decorator(decorator: HandlebarsAST.Decorator) {\n    let { loc } = decorator;\n\n    throw new SyntaxError(\n      `Handlebars decorators are not supported: \"${this.sourceForNode(\n        decorator,\n        decorator.path\n      )}\" at L${loc.start.line}:C${loc.start.column}`,\n      decorator.loc\n    );\n  }\n\n  DecoratorBlock(decoratorBlock: HandlebarsAST.DecoratorBlock) {\n    let { loc } = decoratorBlock;\n\n    throw new SyntaxError(\n      `Handlebars decorator blocks are not supported: \"${this.sourceForNode(\n        decoratorBlock,\n        decoratorBlock.path\n      )}\" at L${loc.start.line}:C${loc.start.column}`,\n      decoratorBlock.loc\n    );\n  }\n\n  SubExpression(sexpr: HandlebarsAST.SubExpression): AST.SubExpression {\n    let { path, params, hash } = acceptCallNodes(this, sexpr);\n    return b.sexpr(path, params, hash, sexpr.loc);\n  }\n\n  PathExpression(path: HandlebarsAST.PathExpression): AST.PathExpression {\n    let { original, loc } = path;\n    let parts: string[];\n\n    if (original.indexOf('/') !== -1) {\n      if (original.slice(0, 2) === './') {\n        throw new SyntaxError(\n          `Using \"./\" is not supported in Glimmer and unnecessary: \"${path.original}\" on line ${\n            loc.start.line\n          }.`,\n          path.loc\n        );\n      }\n      if (original.slice(0, 3) === '../') {\n        throw new SyntaxError(\n          `Changing context using \"../\" is not supported in Glimmer: \"${path.original}\" on line ${\n            loc.start.line\n          }.`,\n          path.loc\n        );\n      }\n      if (original.indexOf('.') !== -1) {\n        throw new SyntaxError(\n          `Mixing '.' and '/' in paths is not supported in Glimmer; use only '.' to separate property paths: \"${\n            path.original\n          }\" on line ${loc.start.line}.`,\n          path.loc\n        );\n      }\n      parts = [path.parts.join('/')];\n    } else if (original === '.') {\n      let locationInfo = `L${loc.start.line}:C${loc.start.column}`;\n      throw new SyntaxError(\n        `'.' is not a supported path in Glimmer; check for a path with a trailing '.' at ${locationInfo}.`,\n        path.loc\n      );\n    } else {\n      parts = path.parts;\n    }\n\n    let thisHead = false;\n\n    // This is to fix a bug in the Handlebars AST where the path expressions in\n    // `{{this.foo}}` (and similarly `{{foo-bar this.foo named=this.foo}}` etc)\n    // are simply turned into `{{foo}}`. The fix is to push it back onto the\n    // parts array and let the runtime see the difference. However, we cannot\n    // simply use the string `this` as it means literally the property called\n    // \"this\" in the current context (it can be expressed in the syntax as\n    // `{{[this]}}`, where the square bracket are generally for this kind of\n    // escaping – such as `{{foo.[\"bar.baz\"]}}` would mean lookup a property\n    // named literally \"bar.baz\" on `this.foo`). By convention, we use `null`\n    // for this purpose.\n    if (original.match(/^this(\\..+)?$/)) {\n      thisHead = true;\n    }\n\n    return {\n      type: 'PathExpression',\n      original: path.original,\n      this: thisHead,\n      parts,\n      data: path.data,\n      loc: path.loc,\n    };\n  }\n\n  Hash(hash: HandlebarsAST.Hash): AST.Hash {\n    let pairs: AST.HashPair[] = [];\n\n    for (let i = 0; i < hash.pairs.length; i++) {\n      let pair = hash.pairs[i];\n      pairs.push(b.pair(pair.key, this.acceptNode<AST.Expression>(pair.value), pair.loc));\n    }\n\n    return b.hash(pairs, hash.loc);\n  }\n\n  StringLiteral(string: HandlebarsAST.StringLiteral) {\n    return b.literal('StringLiteral', string.value, string.loc);\n  }\n\n  BooleanLiteral(boolean: HandlebarsAST.BooleanLiteral) {\n    return b.literal('BooleanLiteral', boolean.value, boolean.loc);\n  }\n\n  NumberLiteral(number: HandlebarsAST.NumberLiteral) {\n    return b.literal('NumberLiteral', number.value, number.loc);\n  }\n\n  UndefinedLiteral(undef: HandlebarsAST.UndefinedLiteral) {\n    return b.literal('UndefinedLiteral', undefined, undef.loc);\n  }\n\n  NullLiteral(nul: HandlebarsAST.NullLiteral) {\n    return b.literal('NullLiteral', null, nul.loc);\n  }\n}\n\nfunction calculateRightStrippedOffsets(original: string, value: string) {\n  if (value === '') {\n    // if it is empty, just return the count of newlines\n    // in original\n    return {\n      lines: original.split('\\n').length - 1,\n      columns: 0,\n    };\n  }\n\n  // otherwise, return the number of newlines prior to\n  // `value`\n  let difference = original.split(value)[0];\n  let lines = difference.split(/\\n/);\n  let lineCount = lines.length - 1;\n\n  return {\n    lines: lineCount,\n    columns: lines[lineCount].length,\n  };\n}\n\nfunction updateTokenizerLocation(\n  tokenizer: Parser['tokenizer'],\n  content: HandlebarsAST.ContentStatement\n) {\n  let line = content.loc.start.line;\n  let column = content.loc.start.column;\n\n  let offsets = calculateRightStrippedOffsets(\n    content.original as Recast<HandlebarsAST.StripFlags, string>,\n    content.value\n  );\n\n  line = line + offsets.lines;\n  if (offsets.lines) {\n    column = offsets.columns;\n  } else {\n    column = column + offsets.columns;\n  }\n\n  tokenizer.line = line;\n  tokenizer.column = column;\n}\n\nfunction acceptCallNodes(\n  compiler: HandlebarsNodeVisitors,\n  node: {\n    path: HandlebarsAST.PathExpression;\n    params: HandlebarsAST.Expression[];\n    hash: HandlebarsAST.Hash;\n  }\n): { path: AST.PathExpression; params: AST.Expression[]; hash: AST.Hash } {\n  let path = compiler.PathExpression(node.path);\n\n  let params = node.params ? node.params.map(e => compiler.acceptNode<AST.Expression>(e)) : [];\n  let hash = node.hash ? compiler.Hash(node.hash) : b.hash();\n\n  return { path, params, hash };\n}\n\nfunction addElementModifier(element: Tag<'StartTag'>, mustache: AST.MustacheStatement) {\n  let { path, params, hash, loc } = mustache;\n\n  if (isLiteral(path)) {\n    let modifier = `{{${printLiteral(path)}}}`;\n    let tag = `<${element.name} ... ${modifier} ...`;\n\n    throw new SyntaxError(\n      `In ${tag}, ${modifier} is not a valid modifier: \"${path.original}\" on line ${loc &&\n        loc.start.line}.`,\n      mustache.loc\n    );\n  }\n\n  let modifier = b.elementModifier(path, params, hash, loc);\n  element.modifiers.push(modifier);\n}\n\nfunction addInElementHash(cursor: string, hash: AST.Hash, loc: AST.SourceLocation) {\n  let hasNextSibling = false;\n  hash.pairs.forEach(pair => {\n    if (pair.key === 'guid') {\n      throw new SyntaxError('Cannot pass `guid` from user space', loc);\n    }\n\n    if (pair.key === 'nextSibling') {\n      hasNextSibling = true;\n    }\n  });\n\n  let guid = b.literal('StringLiteral', cursor);\n  let guidPair = b.pair('guid', guid);\n  hash.pairs.unshift(guidPair);\n\n  if (!hasNextSibling) {\n    let nullLiteral = b.literal('NullLiteral', null);\n    let nextSibling = b.pair('nextSibling', nullLiteral);\n    hash.pairs.push(nextSibling);\n  }\n\n  return hash;\n}\n\nfunction appendDynamicAttributeValuePart(attribute: Attribute, part: AST.MustacheStatement) {\n  attribute.isDynamic = true;\n  attribute.parts.push(part);\n}\n"]},"metadata":{},"sourceType":"module"}