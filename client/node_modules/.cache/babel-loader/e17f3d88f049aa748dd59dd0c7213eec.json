{"ast":null,"code":"'use strict';\n\nexports.__esModule = true; // istanbul ignore next\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar _visitor = require('./visitor');\n\nvar _visitor2 = _interopRequireDefault(_visitor);\n\nfunction WhitespaceControl() {\n  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n  this.options = options;\n}\n\nWhitespaceControl.prototype = new _visitor2['default']();\n\nWhitespaceControl.prototype.Program = function (program) {\n  var doStandalone = !this.options.ignoreStandalone;\n  var isRoot = !this.isRootSeen;\n  this.isRootSeen = true;\n  var body = program.body;\n\n  for (var i = 0, l = body.length; i < l; i++) {\n    var current = body[i],\n        strip = this.accept(current);\n\n    if (!strip) {\n      continue;\n    }\n\n    var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),\n        _isNextWhitespace = isNextWhitespace(body, i, isRoot),\n        openStandalone = strip.openStandalone && _isPrevWhitespace,\n        closeStandalone = strip.closeStandalone && _isNextWhitespace,\n        inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;\n\n    if (strip.close) {\n      omitRight(body, i, true);\n    }\n\n    if (strip.open) {\n      omitLeft(body, i, true);\n    }\n\n    if (doStandalone && inlineStandalone) {\n      omitRight(body, i);\n\n      if (omitLeft(body, i)) {\n        // If we are on a standalone node, save the indent info for partials\n        if (current.type === 'PartialStatement') {\n          // Pull out the whitespace from the final line\n          current.indent = /([ \\t]+$)/.exec(body[i - 1].original)[1];\n        }\n      }\n    }\n\n    if (doStandalone && openStandalone) {\n      omitRight((current.program || current.inverse).body); // Strip out the previous content node if it's whitespace only\n\n      omitLeft(body, i);\n    }\n\n    if (doStandalone && closeStandalone) {\n      // Always strip the next node\n      omitRight(body, i);\n      omitLeft((current.inverse || current.program).body);\n    }\n  }\n\n  return program;\n};\n\nWhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {\n  this.accept(block.program);\n  this.accept(block.inverse); // Find the inverse program that is involed with whitespace stripping.\n\n  var program = block.program || block.inverse,\n      inverse = block.program && block.inverse,\n      firstInverse = inverse,\n      lastInverse = inverse;\n\n  if (inverse && inverse.chained) {\n    firstInverse = inverse.body[0].program; // Walk the inverse chain to find the last inverse that is actually in the chain.\n\n    while (lastInverse.chained) {\n      lastInverse = lastInverse.body[lastInverse.body.length - 1].program;\n    }\n  }\n\n  var strip = {\n    open: block.openStrip.open,\n    close: block.closeStrip.close,\n    // Determine the standalone candiacy. Basically flag our content as being possibly standalone\n    // so our parent can determine if we actually are standalone\n    openStandalone: isNextWhitespace(program.body),\n    closeStandalone: isPrevWhitespace((firstInverse || program).body)\n  };\n\n  if (block.openStrip.close) {\n    omitRight(program.body, null, true);\n  }\n\n  if (inverse) {\n    var inverseStrip = block.inverseStrip;\n\n    if (inverseStrip.open) {\n      omitLeft(program.body, null, true);\n    }\n\n    if (inverseStrip.close) {\n      omitRight(firstInverse.body, null, true);\n    }\n\n    if (block.closeStrip.open) {\n      omitLeft(lastInverse.body, null, true);\n    } // Find standalone else statments\n\n\n    if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {\n      omitLeft(program.body);\n      omitRight(firstInverse.body);\n    }\n  } else if (block.closeStrip.open) {\n    omitLeft(program.body, null, true);\n  }\n\n  return strip;\n};\n\nWhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {\n  return mustache.strip;\n};\n\nWhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {\n  /* istanbul ignore next */\n  var strip = node.strip || {};\n  return {\n    inlineStandalone: true,\n    open: strip.open,\n    close: strip.close\n  };\n};\n\nfunction isPrevWhitespace(body, i, isRoot) {\n  if (i === undefined) {\n    i = body.length;\n  } // Nodes that end with newlines are considered whitespace (but are special\n  // cased for strip operations)\n\n\n  var prev = body[i - 1],\n      sibling = body[i - 2];\n\n  if (!prev) {\n    return isRoot;\n  }\n\n  if (prev.type === 'ContentStatement') {\n    return (sibling || !isRoot ? /\\r?\\n\\s*?$/ : /(^|\\r?\\n)\\s*?$/).test(prev.original);\n  }\n}\n\nfunction isNextWhitespace(body, i, isRoot) {\n  if (i === undefined) {\n    i = -1;\n  }\n\n  var next = body[i + 1],\n      sibling = body[i + 2];\n\n  if (!next) {\n    return isRoot;\n  }\n\n  if (next.type === 'ContentStatement') {\n    return (sibling || !isRoot ? /^\\s*?\\r?\\n/ : /^\\s*?(\\r?\\n|$)/).test(next.original);\n  }\n} // Marks the node to the right of the position as omitted.\n// I.e. {{foo}}' ' will mark the ' ' node as omitted.\n//\n// If i is undefined, then the first child will be marked as such.\n//\n// If mulitple is truthy then all whitespace will be stripped out until non-whitespace\n// content is met.\n\n\nfunction omitRight(body, i, multiple) {\n  var current = body[i == null ? 0 : i + 1];\n\n  if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {\n    return;\n  }\n\n  var original = current.value;\n  current.value = current.value.replace(multiple ? /^\\s+/ : /^[ \\t]*\\r?\\n?/, '');\n  current.rightStripped = current.value !== original;\n} // Marks the node to the left of the position as omitted.\n// I.e. ' '{{foo}} will mark the ' ' node as omitted.\n//\n// If i is undefined then the last child will be marked as such.\n//\n// If mulitple is truthy then all whitespace will be stripped out until non-whitespace\n// content is met.\n\n\nfunction omitLeft(body, i, multiple) {\n  var current = body[i == null ? body.length - 1 : i - 1];\n\n  if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {\n    return;\n  } // We omit the last node if it's whitespace only and not preceded by a non-content node.\n\n\n  var original = current.value;\n  current.value = current.value.replace(multiple ? /\\s+$/ : /[ \\t]+$/, '');\n  current.leftStripped = current.value !== original;\n  return current.leftStripped;\n}\n\nexports['default'] = WhitespaceControl;\nmodule.exports = exports['default'];","map":{"version":3,"mappings":"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","names":["WhitespaceControl","options","arguments","prototype","Program","program","doStandalone","ignoreStandalone","isRoot","isRootSeen","body","i","l","length","current","strip","accept","_isPrevWhitespace","isPrevWhitespace","_isNextWhitespace","isNextWhitespace","openStandalone","closeStandalone","inlineStandalone","close","omitRight","open","omitLeft","type","indent","exec","original","inverse","BlockStatement","DecoratorBlock","PartialBlockStatement","block","firstInverse","lastInverse","chained","openStrip","closeStrip","inverseStrip","Decorator","MustacheStatement","mustache","PartialStatement","CommentStatement","node","undefined","prev","sibling","test","next","multiple","rightStripped","value","replace","leftStripped"],"sources":["../../../../lib/handlebars/compiler/whitespace-control.js"],"sourcesContent":["import Visitor from './visitor';\n\nfunction WhitespaceControl(options = {}) {\n  this.options = options;\n}\nWhitespaceControl.prototype = new Visitor();\n\nWhitespaceControl.prototype.Program = function(program) {\n  const doStandalone = !this.options.ignoreStandalone;\n\n  let isRoot = !this.isRootSeen;\n  this.isRootSeen = true;\n\n  let body = program.body;\n  for (let i = 0, l = body.length; i < l; i++) {\n    let current = body[i],\n      strip = this.accept(current);\n\n    if (!strip) {\n      continue;\n    }\n\n    let _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),\n      _isNextWhitespace = isNextWhitespace(body, i, isRoot),\n      openStandalone = strip.openStandalone && _isPrevWhitespace,\n      closeStandalone = strip.closeStandalone && _isNextWhitespace,\n      inlineStandalone =\n        strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;\n\n    if (strip.close) {\n      omitRight(body, i, true);\n    }\n    if (strip.open) {\n      omitLeft(body, i, true);\n    }\n\n    if (doStandalone && inlineStandalone) {\n      omitRight(body, i);\n\n      if (omitLeft(body, i)) {\n        // If we are on a standalone node, save the indent info for partials\n        if (current.type === 'PartialStatement') {\n          // Pull out the whitespace from the final line\n          current.indent = /([ \\t]+$)/.exec(body[i - 1].original)[1];\n        }\n      }\n    }\n    if (doStandalone && openStandalone) {\n      omitRight((current.program || current.inverse).body);\n\n      // Strip out the previous content node if it's whitespace only\n      omitLeft(body, i);\n    }\n    if (doStandalone && closeStandalone) {\n      // Always strip the next node\n      omitRight(body, i);\n\n      omitLeft((current.inverse || current.program).body);\n    }\n  }\n\n  return program;\n};\n\nWhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function(\n  block\n) {\n  this.accept(block.program);\n  this.accept(block.inverse);\n\n  // Find the inverse program that is involed with whitespace stripping.\n  let program = block.program || block.inverse,\n    inverse = block.program && block.inverse,\n    firstInverse = inverse,\n    lastInverse = inverse;\n\n  if (inverse && inverse.chained) {\n    firstInverse = inverse.body[0].program;\n\n    // Walk the inverse chain to find the last inverse that is actually in the chain.\n    while (lastInverse.chained) {\n      lastInverse = lastInverse.body[lastInverse.body.length - 1].program;\n    }\n  }\n\n  let strip = {\n    open: block.openStrip.open,\n    close: block.closeStrip.close,\n\n    // Determine the standalone candiacy. Basically flag our content as being possibly standalone\n    // so our parent can determine if we actually are standalone\n    openStandalone: isNextWhitespace(program.body),\n    closeStandalone: isPrevWhitespace((firstInverse || program).body)\n  };\n\n  if (block.openStrip.close) {\n    omitRight(program.body, null, true);\n  }\n\n  if (inverse) {\n    let inverseStrip = block.inverseStrip;\n\n    if (inverseStrip.open) {\n      omitLeft(program.body, null, true);\n    }\n\n    if (inverseStrip.close) {\n      omitRight(firstInverse.body, null, true);\n    }\n    if (block.closeStrip.open) {\n      omitLeft(lastInverse.body, null, true);\n    }\n\n    // Find standalone else statments\n    if (\n      !this.options.ignoreStandalone &&\n      isPrevWhitespace(program.body) &&\n      isNextWhitespace(firstInverse.body)\n    ) {\n      omitLeft(program.body);\n      omitRight(firstInverse.body);\n    }\n  } else if (block.closeStrip.open) {\n    omitLeft(program.body, null, true);\n  }\n\n  return strip;\n};\n\nWhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function(\n  mustache\n) {\n  return mustache.strip;\n};\n\nWhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function(\n  node\n) {\n  /* istanbul ignore next */\n  let strip = node.strip || {};\n  return {\n    inlineStandalone: true,\n    open: strip.open,\n    close: strip.close\n  };\n};\n\nfunction isPrevWhitespace(body, i, isRoot) {\n  if (i === undefined) {\n    i = body.length;\n  }\n\n  // Nodes that end with newlines are considered whitespace (but are special\n  // cased for strip operations)\n  let prev = body[i - 1],\n    sibling = body[i - 2];\n  if (!prev) {\n    return isRoot;\n  }\n\n  if (prev.type === 'ContentStatement') {\n    return (sibling || !isRoot ? /\\r?\\n\\s*?$/ : /(^|\\r?\\n)\\s*?$/).test(\n      prev.original\n    );\n  }\n}\nfunction isNextWhitespace(body, i, isRoot) {\n  if (i === undefined) {\n    i = -1;\n  }\n\n  let next = body[i + 1],\n    sibling = body[i + 2];\n  if (!next) {\n    return isRoot;\n  }\n\n  if (next.type === 'ContentStatement') {\n    return (sibling || !isRoot ? /^\\s*?\\r?\\n/ : /^\\s*?(\\r?\\n|$)/).test(\n      next.original\n    );\n  }\n}\n\n// Marks the node to the right of the position as omitted.\n// I.e. {{foo}}' ' will mark the ' ' node as omitted.\n//\n// If i is undefined, then the first child will be marked as such.\n//\n// If mulitple is truthy then all whitespace will be stripped out until non-whitespace\n// content is met.\nfunction omitRight(body, i, multiple) {\n  let current = body[i == null ? 0 : i + 1];\n  if (\n    !current ||\n    current.type !== 'ContentStatement' ||\n    (!multiple && current.rightStripped)\n  ) {\n    return;\n  }\n\n  let original = current.value;\n  current.value = current.value.replace(\n    multiple ? /^\\s+/ : /^[ \\t]*\\r?\\n?/,\n    ''\n  );\n  current.rightStripped = current.value !== original;\n}\n\n// Marks the node to the left of the position as omitted.\n// I.e. ' '{{foo}} will mark the ' ' node as omitted.\n//\n// If i is undefined then the last child will be marked as such.\n//\n// If mulitple is truthy then all whitespace will be stripped out until non-whitespace\n// content is met.\nfunction omitLeft(body, i, multiple) {\n  let current = body[i == null ? body.length - 1 : i - 1];\n  if (\n    !current ||\n    current.type !== 'ContentStatement' ||\n    (!multiple && current.leftStripped)\n  ) {\n    return;\n  }\n\n  // We omit the last node if it's whitespace only and not preceded by a non-content node.\n  let original = current.value;\n  current.value = current.value.replace(multiple ? /\\s+$/ : /[ \\t]+$/, '');\n  current.leftStripped = current.value !== original;\n  return current.leftStripped;\n}\n\nexport default WhitespaceControl;\n"]},"metadata":{},"sourceType":"script"}