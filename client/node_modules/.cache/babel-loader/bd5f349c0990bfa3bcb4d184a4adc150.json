{"ast":null,"code":"\"use strict\";\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.prepareJsxText = exports.createConcat = exports.createRootChildren = exports.createChildren = exports.prependToPath = exports.appendToPath = exports.createPath = exports.resolveExpression = exports.resolveElementChild = exports.resolveStatement = void 0;\n\nvar Babel = require(\"@babel/types\");\n\nvar elements_1 = require(\"./elements\");\n\nvar blockStatements_1 = require(\"./blockStatements\");\n\nvar comments_1 = require(\"./comments\");\n/**\n * Converts the Handlebars expression to NON-JSX JS-compatible expression.\n * Creates top-level expression or expression which need to wrap to JSX\n * expression container.\n */\n\n\nexports.resolveStatement = function (statement) {\n  switch (statement.type) {\n    case 'ElementNode':\n      {\n        return elements_1.convertElement(statement);\n      }\n\n    case 'TextNode':\n      {\n        return Babel.stringLiteral(statement.chars);\n      }\n\n    case 'MustacheStatement':\n      {\n        return exports.resolveExpression(statement.path);\n      }\n\n    case 'BlockStatement':\n      {\n        return blockStatements_1.resolveBlockStatement(statement);\n      }\n\n    case 'MustacheCommentStatement':\n    case 'CommentStatement':\n      {\n        throw new Error('Top level comments currently is not supported');\n      }\n\n    default:\n      {\n        throw new Error(\"Unexpected expression \\\"\" + statement.type + \"\\\"\");\n      }\n  }\n};\n/**\n * Converts the Handlebars node to JSX-children-compatible child element.\n * Creates JSX expression or expression container with JS expression, to place\n * to children of a JSX element.\n */\n\n\nexports.resolveElementChild = function (statement) {\n  switch (statement.type) {\n    case 'ElementNode':\n      {\n        return elements_1.convertElement(statement);\n      }\n\n    case 'TextNode':\n      {\n        return exports.prepareJsxText(statement.chars);\n      }\n\n    case 'MustacheCommentStatement':\n    case 'CommentStatement':\n      {\n        return comments_1.createComment(statement);\n      }\n    // If it expression, create a expression container\n\n    default:\n      {\n        return Babel.jsxExpressionContainer(exports.resolveStatement(statement));\n      }\n  }\n};\n/**\n * Converts Hbs expression to Babel expression\n */\n\n\nexports.resolveExpression = function (expression) {\n  switch (expression.type) {\n    case 'PathExpression':\n      {\n        return exports.createPath(expression);\n      }\n\n    case 'BooleanLiteral':\n      {\n        return Babel.booleanLiteral(expression.value);\n      }\n\n    case 'NullLiteral':\n      {\n        return Babel.nullLiteral();\n      }\n\n    case 'NumberLiteral':\n      {\n        return Babel.numericLiteral(expression.value);\n      }\n\n    case 'StringLiteral':\n      {\n        return Babel.stringLiteral(expression.value);\n      }\n\n    case 'UndefinedLiteral':\n      {\n        return Babel.identifier('undefined');\n      }\n\n    default:\n      {\n        throw new Error('Unexpected mustache statement');\n      }\n  }\n};\n/**\n * Returns path to variable\n */\n\n\nexports.createPath = function (pathExpression) {\n  var parts = pathExpression.parts;\n\n  if (parts.length === 0) {\n    throw new Error('Unexpected empty expression parts');\n  } // Start identifier\n\n\n  var acc = Babel.identifier(parts[0]);\n\n  for (var i = 1; i < parts.length; i++) {\n    acc = exports.appendToPath(acc, Babel.identifier(parts[i]));\n  }\n\n  return acc;\n};\n/**\n * Appends item to path\n */\n\n\nexports.appendToPath = function (path, append) {\n  return Babel.memberExpression(path, append);\n};\n/**\n * Prepends item to path\n */\n\n\nexports.prependToPath = function (path, prepend) {\n  return Babel.memberExpression(prepend, path);\n};\n/**\n * Converts child statements of element to JSX-compatible expressions\n * @param body List of Glimmer statements\n */\n\n\nexports.createChildren = function (body) {\n  return body.reduce(function (acc, statement) {\n    var child = exports.resolveElementChild(statement);\n    return Array.isArray(child) ? __spreadArrays(acc, child) : __spreadArrays(acc, [child]);\n  }, []);\n};\n/**\n * Converts root children\n */\n\n\nexports.createRootChildren = function (body) {\n  return body.length === 1 ? exports.resolveStatement(body[0]) : elements_1.createFragment(exports.createChildren(body));\n};\n/**\n * Creates attribute value concatenation\n */\n\n\nexports.createConcat = function (parts) {\n  return parts.reduce(function (acc, item) {\n    if (acc == null) {\n      return exports.resolveStatement(item);\n    }\n\n    return Babel.binaryExpression('+', acc, exports.resolveStatement(item));\n  }, null);\n};\n/**\n * Escapes syntax chars in jsx text\n * @param text\n */\n\n\nexports.prepareJsxText = function (text) {\n  // Escape jsx syntax chars\n  var parts = text.split(/(:?{|})/);\n\n  if (parts.length === 1) {\n    return Babel.jsxText(text);\n  }\n\n  return parts.map(function (item) {\n    return item === '{' || item === '}' ? Babel.jsxExpressionContainer(Babel.stringLiteral(item)) : Babel.jsxText(item);\n  });\n};","map":{"version":3,"names":["__spreadArrays","s","i","il","arguments","length","r","Array","k","a","j","jl","Object","defineProperty","exports","value","prepareJsxText","createConcat","createRootChildren","createChildren","prependToPath","appendToPath","createPath","resolveExpression","resolveElementChild","resolveStatement","Babel","require","elements_1","blockStatements_1","comments_1","statement","type","convertElement","stringLiteral","chars","path","resolveBlockStatement","Error","createComment","jsxExpressionContainer","expression","booleanLiteral","nullLiteral","numericLiteral","identifier","pathExpression","parts","acc","append","memberExpression","prepend","body","reduce","child","isArray","createFragment","item","binaryExpression","text","split","jsxText","map"],"sources":["C:/Users/KA-001/HT Coding projects/capstone_cincinnati/node_modules/handlebars-to-jsx/dist/expressions.js"],"sourcesContent":["\"use strict\";\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.prepareJsxText = exports.createConcat = exports.createRootChildren = exports.createChildren = exports.prependToPath = exports.appendToPath = exports.createPath = exports.resolveExpression = exports.resolveElementChild = exports.resolveStatement = void 0;\nvar Babel = require(\"@babel/types\");\nvar elements_1 = require(\"./elements\");\nvar blockStatements_1 = require(\"./blockStatements\");\nvar comments_1 = require(\"./comments\");\n/**\n * Converts the Handlebars expression to NON-JSX JS-compatible expression.\n * Creates top-level expression or expression which need to wrap to JSX\n * expression container.\n */\nexports.resolveStatement = function (statement) {\n    switch (statement.type) {\n        case 'ElementNode': {\n            return elements_1.convertElement(statement);\n        }\n        case 'TextNode': {\n            return Babel.stringLiteral(statement.chars);\n        }\n        case 'MustacheStatement': {\n            return exports.resolveExpression(statement.path);\n        }\n        case 'BlockStatement': {\n            return blockStatements_1.resolveBlockStatement(statement);\n        }\n        case 'MustacheCommentStatement':\n        case 'CommentStatement': {\n            throw new Error('Top level comments currently is not supported');\n        }\n        default: {\n            throw new Error(\"Unexpected expression \\\"\" + statement.type + \"\\\"\");\n        }\n    }\n};\n/**\n * Converts the Handlebars node to JSX-children-compatible child element.\n * Creates JSX expression or expression container with JS expression, to place\n * to children of a JSX element.\n */\nexports.resolveElementChild = function (statement) {\n    switch (statement.type) {\n        case 'ElementNode': {\n            return elements_1.convertElement(statement);\n        }\n        case 'TextNode': {\n            return exports.prepareJsxText(statement.chars);\n        }\n        case 'MustacheCommentStatement':\n        case 'CommentStatement': {\n            return comments_1.createComment(statement);\n        }\n        // If it expression, create a expression container\n        default: {\n            return Babel.jsxExpressionContainer(exports.resolveStatement(statement));\n        }\n    }\n};\n/**\n * Converts Hbs expression to Babel expression\n */\nexports.resolveExpression = function (expression) {\n    switch (expression.type) {\n        case 'PathExpression': {\n            return exports.createPath(expression);\n        }\n        case 'BooleanLiteral': {\n            return Babel.booleanLiteral(expression.value);\n        }\n        case 'NullLiteral': {\n            return Babel.nullLiteral();\n        }\n        case 'NumberLiteral': {\n            return Babel.numericLiteral(expression.value);\n        }\n        case 'StringLiteral': {\n            return Babel.stringLiteral(expression.value);\n        }\n        case 'UndefinedLiteral': {\n            return Babel.identifier('undefined');\n        }\n        default: {\n            throw new Error('Unexpected mustache statement');\n        }\n    }\n};\n/**\n * Returns path to variable\n */\nexports.createPath = function (pathExpression) {\n    var parts = pathExpression.parts;\n    if (parts.length === 0) {\n        throw new Error('Unexpected empty expression parts');\n    }\n    // Start identifier\n    var acc = Babel.identifier(parts[0]);\n    for (var i = 1; i < parts.length; i++) {\n        acc = exports.appendToPath(acc, Babel.identifier(parts[i]));\n    }\n    return acc;\n};\n/**\n * Appends item to path\n */\nexports.appendToPath = function (path, append) {\n    return Babel.memberExpression(path, append);\n};\n/**\n * Prepends item to path\n */\nexports.prependToPath = function (path, prepend) {\n    return Babel.memberExpression(prepend, path);\n};\n/**\n * Converts child statements of element to JSX-compatible expressions\n * @param body List of Glimmer statements\n */\nexports.createChildren = function (body) {\n    return body.reduce(function (acc, statement) {\n        var child = exports.resolveElementChild(statement);\n        return Array.isArray(child) ? __spreadArrays(acc, child) : __spreadArrays(acc, [child]);\n    }, []);\n};\n/**\n * Converts root children\n */\nexports.createRootChildren = function (body) {\n    return body.length === 1 ? exports.resolveStatement(body[0]) : elements_1.createFragment(exports.createChildren(body));\n};\n/**\n * Creates attribute value concatenation\n */\nexports.createConcat = function (parts) {\n    return parts.reduce(function (acc, item) {\n        if (acc == null) {\n            return exports.resolveStatement(item);\n        }\n        return Babel.binaryExpression('+', acc, exports.resolveStatement(item));\n    }, null);\n};\n/**\n * Escapes syntax chars in jsx text\n * @param text\n */\nexports.prepareJsxText = function (text) {\n    // Escape jsx syntax chars\n    var parts = text.split(/(:?{|})/);\n    if (parts.length === 1) {\n        return Babel.jsxText(text);\n    }\n    return parts.map(function (item) {\n        return item === '{' || item === '}' ? Babel.jsxExpressionContainer(Babel.stringLiteral(item)) : Babel.jsxText(item);\n    });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}